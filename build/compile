#!/usr/bin/env bash

# generate code from templates <https://github.com/TekWizely/bash-tpl>
#  - auto import function with pattern folder::(._::)_(functionName) =>
#    Folder/functionName.sh
#  - auto import \_.sh if at least one function imported in the directory

CURRENT_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
SRC_DIR="$(cd "${ROOT_DIR}/src" && pwd -P)"

# shellcheck source=/src/_includes/_header.sh
source "${SRC_DIR}/_includes/_header.sh"
# shellcheck source=/src/Log/_.sh
source "${SRC_DIR}/Log/_.sh"
# shellcheck source=/src/Array/contains.sh
source "${SRC_DIR}/Array/contains.sh"

# shellcheck disable=SC2034
((failures = 0)) || true

shopt -s expand_aliases
set -o pipefail
set -o errexit
# a log is generated when a command fails
set -o errtrace
# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob
export TERM=xterm-256color

removeDuplicatedShebangs() {
  sed '1!{/^#!/d;}'
}

removeEmptyLinesFromBeginning() {
  awk 'NF {p=1} p'
}

# @see https://unix.stackexchange.com/a/653883
trimEmptyLines() {
  awk '
    NF {print saved $0; saved = ""; started = 1; next}
    started {saved = saved $0 ORS}
  '
}

catFileCleaned() {
  # remove shebang line and remove empty lines at beginning and end of file
  sed '1d' "$1" | trimEmptyLines
  # ensure we have at least one empty line between 2 functions
  echo
}

# Loop until no more file to import
# 1. generate code from template
# 2. remove duplicated #!/usr/bin/env bash
# 3. deduce files to import based on [A-Za-z0-9]+::[A-Za-z0-9]+ pattern
#    (skip files already imported and those that do not exist)
# 4. inject import files at the beginning of the file
# TODO I could get rid of bash-tpl by providing special function IMPORT::dir::file
#    this function should be replaced inline

INPUT_FILE="$1"
INPUT_RELATIVE_FILE="$2"
BIN_FILE_RELATIVE2ROOT_DIR="$3"
FILES_IMPORTED=("${INPUT_FILE}")

COMPILED_FILE="$(mktemp)"
IMPORTED_FUNCTIONS_TEMP_SOURCE="$(mktemp)"
# clean temp files on exit
trap 'rm -f "${COMPILED_FILE}" "${IMPORTED_FUNCTIONS_TEMP_SOURCE}" || true' EXIT INT ABRT TERM

# shellcheck source=/dev/null
(BIN_FILE_RELATIVE2ROOT_DIR="${BIN_FILE_RELATIVE2ROOT_DIR}" SRC_FILE_PATH="${INPUT_RELATIVE_FILE}" source <("${ROOT_DIR}/build/bash-tpl" "${INPUT_FILE}")) | removeDuplicatedShebangs >"${COMPILED_FILE}"

((FUNCTIONS_IMPORTED = 1))
((ITERATION = 1))
while ((FUNCTIONS_IMPORTED >= 1)); do
  (echo >&2 -e "\tIteration #${ITERATION}")
  ((FUNCTIONS_IMPORTED = 0)) || true
  echo >"${IMPORTED_FUNCTIONS_TEMP_SOURCE}"

  cp "${COMPILED_FILE}" "${COMPILED_FILE}.${ITERATION}"
  readarray -t FUNCTIONS_TO_IMPORT < <(
    grep -Poi '([a-z0-9_-]+::[a-z0-9_-]+)([ \t);`]|$)' "${COMPILED_FILE}" |
      awk '{$1=$1};1' |
      sort |
      uniq
  )
  for functionToImport in "${FUNCTIONS_TO_IMPORT[@]}"; do
    fileToImport="${SRC_DIR}/$(echo "${functionToImport}" | sed -r 's#::#/#g').sh"
    if ! Array::contains "${fileToImport}" "${FILES_IMPORTED[@]}"; then
      if [[ -f "${fileToImport}" ]]; then
        # check if we need to import _.sh
        underscoreFile="$(dirname "${fileToImport}")/_.sh"
        if ! Array::contains "${underscoreFile}" "${FILES_IMPORTED[@]}" &&
          [[ -f "${underscoreFile}" ]]; then
          (echo >&2 -e "\tImporting ${underscoreFile} ...")
          catFileCleaned "${underscoreFile}" >>"${IMPORTED_FUNCTIONS_TEMP_SOURCE}"
          FILES_IMPORTED+=("${underscoreFile}")
        fi

        (echo >&2 -e "\tImporting ${fileToImport} ...")
        catFileCleaned "${fileToImport}" >>"${IMPORTED_FUNCTIONS_TEMP_SOURCE}"
      else
        (echo >&2 -e "${__WARNING_COLOR}\tFile ${fileToImport} does not exist${__RESET_COLOR}")
      fi
      FILES_IMPORTED+=("${fileToImport}")
      ((++FUNCTIONS_IMPORTED))
    fi
  done
  sed -i "/# FUNCTIONS/ r ${IMPORTED_FUNCTIONS_TEMP_SOURCE}" "${COMPILED_FILE}"
  ((ITERATION++))
done
cat -s "${COMPILED_FILE}"
