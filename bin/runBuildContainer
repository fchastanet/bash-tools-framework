#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/runBuildContainer.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${FRAMEWORK_ROOT_DIR}/bin/runBuildContainer
# EMBED "${FRAMEWORK_ROOT_DIR}/bin/buildPushDockerImage" AS buildPushDockerImage
# VAR_RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR=..
# FACADE

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
mkdir -p "${PERSISTENT_TMPDIR}"

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if can
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap() {
  local glue="${1-}"
  local -i glueLength=0
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  local -i firstLine=1
  shift || true
  (($# != 0)) || return 0

  local arg

  # convert multi-line arg to several args
  local -a allArgs=()
  for arg in "$@"; do
    local line
    local IFS=$'\n'
    arg="$(echo -e "${arg}")"
    while read -r line; do
      if [[ -z "${line}" ]]; then
        allArgs+=($'\n')
      else
        allArgs+=("${line}")
      fi
    done <<<"${arg}"
  done
  set -- "${allArgs[@]}"

  local -i currentLineLength=0
  local needEcho="0"
  local arg="$1"
  local argNoAnsi
  local -i argNoAnsiLength=0

  while (($# > 0)); do
    argNoAnsi="$(echo "${arg%%*( )}" | Filters::removeAnsiCodes)"
    ((argNoAnsiLength = ${#argNoAnsi})) || true
    if (($# < 1 && argNoAnsiLength == 0)); then
      break
    fi
    if [[ "${arg}" = $'\n' ]]; then
      if [[ "${needEcho}" = "1" ]]; then
        needEcho="0"
      fi
      echo ""
      ((currentLineLength = 0)) || true
      ((glueLength = 0)) || true
      shift || return 0
      arg="$1"
    elif ((argNoAnsiLength < maxLineLength - currentLineLength - glueLength)); then
      # arg can be stored as a whole on current line
      if ((glueLength > 0)); then
        echo -e -n "${glue}"
        ((currentLineLength += glueLength))
      fi
      if ((currentLineLength == 0 && firstLine == 0)); then
        echo -n "${indentStr}"
      fi
      echo -e -n "${arg}" | sed 's/[\t ]*$//g'
      needEcho="1"
      ((currentLineLength += argNoAnsiLength))
      ((glueLength = ${#glue})) || true
      shift || return 0
      arg="$1"
    else
      if ((argNoAnsiLength >= (maxLineLength - indentNextLine))); then
        if ((currentLineLength == 0 && firstLine == 0)); then
          echo -n "${indentStr}"
          ((currentLineLength += indentNextLine))
        fi
        # arg can be stored on a whole line
        if ((glueLength > 0)); then
          echo -e -n "${glue}"
          ((currentLineLength += glueLength))
        fi
        local -i length
        ((length = maxLineLength - currentLineLength)) || true
        echo -e "${arg:0:${length}}" | sed 's/[\t ]*$//g'
        ((currentLineLength = 0)) || true
        ((glueLength = 0)) || true
        arg="${arg:${length}}"
        needEcho="0"
      else
        # arg cannot be stored on a whole line, so we add it on next line as a whole
        echo
        echo -e -n "${indentStr}${arg}" | sed 's/[\t ]*$//g'
        ((glueLength = ${#glue})) || true
        ((currentLineLength = argNoAnsiLength))
        arg="" # allows to go to next arg
        needEcho="1"
      fi
      if [[ -z "${arg}" ]]; then
        shift || return 0
        arg="$1"
      fi
    fi
    ((firstLine = 0)) || true
  done
  if [[ "${needEcho}" = "1" ]]; then
    echo
  fi
}

#set -x
#Array::wrap ":" 40 0 "Lorem ipsum dolor sit amet," "consectetur adipiscing elit." "Curabitur ac elit id massa" "condimentum finibus."

# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"

  if [[ ! -f "${targetFile}" ]]; then
    mkdir -p "$(dirname "${targetFile}")"
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "$(dirname "${targetFile}")"
  fi
}

# @description ensure env files are loaded
# @noargs
# @exitcode 1 if getOrderedConfFiles fails
# @exitcode 2 if one of env files fails to load
# @stderr diagnostics information is displayed
Env::requireLoad() {
  local configFilesStr
  configFilesStr="$(Env::getOrderedConfFiles)" || return 1

  local -a configFiles
  readarray -t configFiles <<<"${configFilesStr}"

  # if empty string, there will be one element
  if ((${#configFiles[@]} == 0)) || [[ -z "${configFilesStr}" ]]; then
    # should not happen, as there is always default file
    Log::displaySkipped "no env file to load"
    return 0
  fi

  Env::mergeConfFiles "${configFiles[@]}" || {
    Log::displayError "while loading config files: ${configFiles[*]}"
    return 2
  }
}

# @description load .framework-config
# @arg $1 loadedConfigFile:&String (passed by reference) the finally loaded configuration file path
# @arg $@ srcDirs:String[] the src directories in which .framework-config file will be searched
# @stdout the config file path loaded if any
# @exitcode 0 if .framework-config file has been found in srcDirs provided
# @exitcode 1 if .framework-config file not found
# @see Conf::loadNearestFile
Framework::loadConfig() {
  # shellcheck disable=SC2034
  local -n loadConfig_loadedConfigFile=$1
  shift || true
  Conf::loadNearestFile ".framework-config" loadConfig_loadedConfigFile "$@"
}

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__INFO_COLOR}${type}    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if
        ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null ||
          ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null
      then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi

  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf '%*s\n' "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo)}" '' | tr ' ' "${character}"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
# @stderr diagnostic information + help if second argument is provided
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  [[ -t 1 || -t 2 ]]
}

# @description Load the nearest config file
# in next example will search first .framework-config file in "srcDir1"
# then if not found will go in up directories until /
# then will search in "srcDir2"
# then if not found will go in up directories until /
# source the file if found
# @example
#   Conf::loadNearestFile ".framework-config" "srcDir1" "srcDir2"
#
# @arg $1 configFileName:String config file name to search
# @arg $2 loadedFile:String (passed by reference) will return the loaded config file name
# @arg $@ srcDirs:String[] source directories in which the config file will be searched
# @exitcode 0 if file found
# @exitcode 1 if file not found
Conf::loadNearestFile() {
  local configFileName="$1"
  local -n loadedFile="$2"
  shift 2 || true
  local -a srcDirs=("$@")
  for srcDir in "${srcDirs[@]}"; do
    configFile="$(File::upFind "${srcDir}" "${configFileName}" || true)"
    if [[ -n "${configFile}" ]]; then
      # shellcheck source=/.framework-config
      source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
      Log::displayDebug "Config file ${configFile} is loaded"
      # shellcheck disable=SC2034
      loadedFile="${configFile}"
      return 0
    fi
  done

  Log::displayWarning "Config file '${configFileName}' not found in any source directories provided"
  return 1
}

# @description get list of env files to load
# in order to make them available for Env::requireLoad
# @env BASH_FRAMEWORK_ENV_FILES String[] list of env files that should be loaded
# @exitcode 1 if one of the env file cannot be generated
# @exitcode 2 if one of the env file is not a file or readable
# @stdout the env files asked to be loaded
# @stderr diagnostic information on failure
# @see https://github.com/fchastanet/bash-tools-framework/blob/master/FrameworkDoc.md#config_file_order
Env::getOrderedConfFiles() {
  local -a configFiles=()

  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi

  local defaultEnvFile
  defaultEnvFile="$(Env::createDefaultEnvFile)" || return 1
  configFiles+=("${defaultEnvFile}")

  local file
  for file in "${configFiles[@]}"; do
    if [[ ! -f "${file}" || ! -r "${file}" ]]; then
      Log::displayError "One of the config file is not available '${file}'"
      return 2
    fi
    echo "${file}"
  done
}

# @description merge and load conf files specified as argument
# - files are cleaned from ay comment
# - missing quotes after property = sign are added automatically
# - automatic remove of all whitespace before and after declarations
# - bash arrays are not supported
# - if a variable is declared in first file and overridden later on
#   in the same file or in subsequent files, those overloads will be
#   ignored
# @warning if an error occurs while loading one of the config file, exit code 3 but environment could be partially loaded
# @arg $@ args:String[] list of configuration files to load in order
# @set envVars String will set in environment all the variables that have been declared in the config files
# @env envVars String the env variables of the current script could be used to interpret variables during config files parsing
# @exitcode 0 if no config files provided or load completed successfully
# @exitcode 1 if error occurred during parsing the config files (file not found, grep, awk or sed error)
# @exitcode 2 if temporary file cannot be created
# @exitcode 3 if an error occurred during config file sourcing
# @stderr diagnostics information is displayed
# @see largely inspired but modified from https://opensource.com/article/21/5/processing-configuration-files-shell
Env::mergeConfFiles() {
  local -a configFileList=("$@")

  if ((${#configFileList[@]} == 0)); then
    return 0
  fi

  local combinedConfigFile
  combinedConfigFile="$(Framework::createTempFile "mergeConfFiles")" || return 2

  (
    # removes any trailing whitespace from each file, if any
    # this is absolutely required when importing into ConfigMaps
    # put quotes around values
    sed -E -e $'s/\s*$// ; /^$/d ; /^#.*$/d ; s/=([^"\'].*)$/="\\1"/' "${configFileList[@]}" |
      # remove all comment lines
      Filters::commentLines |
      # iterates over each file and prints (default awk behavior)
      # each unique line; only takes first value and ignores duplicates
      awk -F= '!line[$1]++'
  ) >"${combinedConfigFile}" || return 1

  # have to export everything, and source it twice:
  # 1) first source is to realize variables
  # 2) second time is to realize references
  set -o allexport
  # shellcheck source=.framework-config
  source "${combinedConfigFile}" || return 3
  # shellcheck source=.framework-config
  source "${combinedConfigFile}" || return 3
  set +o allexport
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description remove ansi codes from input or files given as argument
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# @see https://en.wikipedia.org/wiki/ANSI_escape_code
# shellcheck disable=SC2120
Filters::removeAnsiCodes() {
  # cspell:disable
  sed -E 's/\x1b\[[0-9;]*[mGKHF]//g' "$@"
  # cspell:enable
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displaySkipped "Log file ${file} doesn't exist yet"
    return 0
  fi
  for i in $(seq $((maxLogFilesCount - 1)) -1 1); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @exitcode 0 always successful
UI::requireTheme() {
  UI::theme "${BASH_FRAMEWORK_THEME-default}"
}

# @description default env file with all default values
# @stdout the default env filepath
Env::createDefaultEnvFile() {
  local envFile
  envFile="$(Framework::createTempFile "createDefaultEnvFileEnvFile")" || return 2

  (
    echo "BASH_FRAMEWORK_THEME=${BASH_FRAMEWORK_THEME:-default}"
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_WARNING}}"
    # shellcheck disable=SC2016
    echo 'BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"'
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${envFile}"
  echo "${envFile}"
}

# @description search a file in parent directories
#
# @arg $1 fromPath:String path
# @arg $2 fileName:String
# @arg $3 untilInclusivePath:String (optional) find for given file until reaching this folder (default value: /)
# @arg $@ untilInclusivePaths:String[] list of untilInclusivePath
# @stdout The filename if found
# @exitcode 1 if the command failed or file not found
File::upFind() {
  local fromPath="$1"
  shift || true
  local fileName="$1"
  shift || true
  local untilInclusivePath="${1:-/}"
  shift || true

  if [[ -f "${fromPath}" ]]; then
    fromPath="$(dirname "${fromPath}")"
  fi
  while true; do
    if [[ -f "${fromPath}/${fileName}" ]]; then
      echo "${fromPath}/${fileName}"
      return 0
    fi
    if Array::contains "${fromPath}" "${untilInclusivePath}" "$@" "/"; then
      return 1
    fi
    fromPath="$(readlink -f "${fromPath}"/..)"
  done
  return 1
}

# @description remove comment lines from input or files provided as arguments
# @arg $@ files:String[] (optional) the files to filter
# @env commentLinePrefix String the comment line prefix (default value: #)
# @exitcode 0 if lines filtered or not
# @exitcode 2 if grep fails for any other reasons than not found
# @stdin the file as stdin to filter (alternative to files argument)
# @stdout the filtered lines
# shellcheck disable=SC2120
Filters::commentLines() {
  grep -vxE "[[:blank:]]*(${commentLinePrefix:-#}.*)?" "$@" || test $? = 1
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# FUNCTIONS

Compiler::Embed::extractFileFromBase64 "${PERSISTENT_TMPDIR:-/tmp}/f570a06fa3f301d870d231647c6c8b78/buildPushDockerImage" "IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZBQ0FERSBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtdG9vbHMtZnJhbWV3b3JrL3RyZWUvbWFzdGVyL3NyYy9fYmluYXJpZXMvYnVpbGRQdXNoRG9ja2VySW1hZ2Uuc2gKIyBETyBOT1QgRURJVCBJVAojIEBnZW5lcmF0ZWQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIyODgsU0MyMDM0CiMgQklOX0ZJTEU9JHtGUkFNRVdPUktfUk9PVF9ESVJ9L2Jpbi9idWlsZFB1c2hEb2NrZXJJbWFnZQojIFZBUl9SRUxBVElWRV9GUkFNRVdPUktfRElSX1RPX0NVUlJFTlRfRElSPS4uCiMgRkFDQURFCgojIGVuc3VyZSB0aGF0IG5vIHVzZXIgYWxpYXNlcyBjb3VsZCBpbnRlcmZlcmUgd2l0aAojIGNvbW1hbmRzIHVzZWQgaW4gdGhpcyBzY3JpcHQKdW5hbGlhcyAtYSB8fCB0cnVlCnNob3B0IC11IGV4cGFuZF9hbGlhc2VzCgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKKChmYWlsdXJlcyA9IDApKSB8fCB0cnVlCgojIEJhc2ggd2lsbCByZW1lbWJlciAmIHJldHVybiB0aGUgaGlnaGVzdCBleGl0IGNvZGUgaW4gYSBjaGFpbiBvZiBwaXBlcy4KIyBUaGlzIHdheSB5b3UgY2FuIGNhdGNoIHRoZSBlcnJvciBpbnNpZGUgcGlwZXMsIGUuZy4gbXlzcWxkdW1wIHwgZ3ppcApzZXQgLW8gcGlwZWZhaWwKc2V0IC1vIGVycmV4aXQKCiMgQ29tbWFuZCBTdWJzdGl0dXRpb24gY2FuIGluaGVyaXQgZXJyZXhpdCBvcHRpb24gc2luY2UgYmFzaCB2NC40CnNob3B0IC1zIGluaGVyaXRfZXJyZXhpdCB8fCB0cnVlCgojIGEgbG9nIGlzIGdlbmVyYXRlZCB3aGVuIGEgY29tbWFuZCBmYWlscwpzZXQgLW8gZXJydHJhY2UKCiMgdXNlIG51bGxnbG9iIHNvIHRoYXQgKGZpbGUqLnBocCkgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgbm8gZmlsZSBtYXRjaGVzIHRoZSB3aWxkY2FyZApzaG9wdCAtcyBudWxsZ2xvYgoKIyBlbnN1cmUgcmVnZXhwIGFyZSBpbnRlcnByZXRlZCB3aXRob3V0IGFjY2VudHVhdGVkIGNoYXJhY3RlcnMKZXhwb3J0IExDX0FMTD1QT1NJWAoKZXhwb3J0IFRFUk09eHRlcm0tMjU2Y29sb3IKCiMgYXZvaWQgaW50ZXJhY3RpdmUgaW5zdGFsbApleHBvcnQgREVCSUFOX0ZST05URU5EPW5vbmludGVyYWN0aXZlCmV4cG9ydCBERUJDT05GX05PTklOVEVSQUNUSVZFX1NFRU49dHJ1ZQoKIyBzdG9yZSBjb21tYW5kIGFyZ3VtZW50cyBmb3IgbGF0ZXIgdXNhZ2UKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CmRlY2xhcmUgLWEgQkFTSF9GUkFNRVdPUktfQVJHVj0oIiRAIikKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CmRlY2xhcmUgLWEgT1JJR0lOQUxfQkFTSF9GUkFNRVdPUktfQVJHVj0oIiRAIikKCiMgQHNlZSBodHRwczovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8zODY4NTYKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3CmludGVycnVwdE1hbmFnZW1lbnQoKSB7CiAgIyByZXN0b3JlIFNJR0lOVCBoYW5kbGVyCiAgdHJhcCAtIElOVAogICMgZW5zdXJlIHRoYXQgQ3RybC1DIGlzIHRyYXBwZWQgYnkgdGhpcyBzY3JpcHQgYW5kIG5vdCBieSBzdWIgcHJvY2VzcwogICMgcmVwb3J0IHRvIHRoZSBwYXJlbnQgdGhhdCB3ZSBoYXZlIGluZGVlZCBiZWVuIGludGVycnVwdGVkCiAga2lsbCAtcyBJTlQgIiQkIgp9CnRyYXAgaW50ZXJydXB0TWFuYWdlbWVudCBJTlQKU0NSSVBUX05BTUU9JHswIyMqL30KUkVBTF9TQ1JJUFRfRklMRT0iJChyZWFkbGluayAtZSAiJChyZWFscGF0aCAiJHtCQVNIX1NPVVJDRVswXX0iKSIpIgppZiBbWyAtbiAiJHtFTUJFRF9DVVJSRU5UX0RJUn0iIF1dOyB0aGVuCiAgQ1VSUkVOVF9ESVI9IiR7RU1CRURfQ1VSUkVOVF9ESVJ9IgplbHNlCiAgQ1VSUkVOVF9ESVI9IiQoY2QgIiQocmVhZGxpbmsgLWUgIiR7UkVBTF9TQ1JJUFRfRklMRSUvKn0iKSIgJiYgcHdkIC1QKSIKZmkKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFRlbXAgZGlyIG1hbmFnZW1lbnQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLRUVQX1RFTVBfRklMRVM9IiR7S0VFUF9URU1QX0ZJTEVTOi0wfSIKZXhwb3J0IEtFRVBfVEVNUF9GSUxFUwoKIyBQRVJTSVNURU5UX1RNUERJUiBpcyBub3QgZGVsZXRlZCBieSB0cmFwcwpQRVJTSVNURU5UX1RNUERJUj0iJHtUTVBESVI6LS90bXB9L2Jhc2gtZnJhbWV3b3JrIgpleHBvcnQgUEVSU0lTVEVOVF9UTVBESVIKbWtkaXIgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVJ9IgoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClRNUERJUj0iJChta3RlbXAgLWQgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9IiAtdCBiYXNoLWZyYW1ld29yay0kJC1YWFhYWFgpIgpleHBvcnQgVE1QRElSCgojIHRlbXAgZGlyIGNsZWFuaW5nCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNwpjbGVhbk9uRXhpdCgpIHsKICBpZiBbWyAiJHtLRUVQX1RFTVBfRklMRVM6LTB9IiA9ICIxIiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5SW5mbyAiS0VFUF9URU1QX0ZJTEVTPTEgdGVtcCBmaWxlcyBrZXB0IGhlcmUgJyR7VE1QRElSfSciCiAgZWxpZiBbWyAtbiAiJHtUTVBESVIreHh4fSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheURlYnVnICJLRUVQX1RFTVBfRklMRVM9MCByZW1vdmluZyB0ZW1wIGZpbGVzICcke1RNUERJUn0nIgogICAgcm0gLVJmICIke1RNUERJUjotL3RtcC9mYWtlfSIgPi9kZXYvbnVsbCAyPiYxCiAgZmkKfQp0cmFwIGNsZWFuT25FeGl0IEVYSVQgSFVQIFFVSVQgQUJSVCBURVJNCgojIEBkZXNjcmlwdGlvbiBjb25jYXQgZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGggYSBzZXBhcmF0b3IKIyBidXQgd3JhcHBpbmcgdGV4dCB3aGVuIGxpbmUgbGVuZ3RoIGlzIG1vcmUgdGhhbiBwcm92aWRlZCBhcmd1bWVudAojIFRoZSBhbGdvcml0aG0gd2lsbCB0cnkgbm90IHRvIGN1dCB0aGUgYXJyYXkgZWxlbWVudCBpZiBjYW4KIwojIEBhcmcgJDEgZ2x1ZTpTdHJpbmcKIyBAYXJnICQyIG1heExpbmVMZW5ndGg6aW50CiMgQGFyZyAkMyBpbmRlbnROZXh0TGluZTppbnQKIyBAYXJnICRAIGFycmF5OlN0cmluZ1tdCkFycmF5Ojp3cmFwKCkgewogIGxvY2FsIGdsdWU9IiR7MS19IgogIGxvY2FsIC1pIGdsdWVMZW5ndGg9MAogIHNoaWZ0IHx8IHRydWUKICBsb2NhbCAtaSBtYXhMaW5lTGVuZ3RoPSQxCiAgc2hpZnQgfHwgdHJ1ZQogIGxvY2FsIC1pIGluZGVudE5leHRMaW5lPSQxCiAgbG9jYWwgaW5kZW50U3RyPSIiCiAgaWYgKChpbmRlbnROZXh0TGluZSA+IDApKTsgdGhlbgogICAgaW5kZW50U3RyPSIkKGhlYWQgLWMgIiR7aW5kZW50TmV4dExpbmV9IiA8L2Rldi96ZXJvIHwgdHIgJ1wwJyAiICIpIgogIGZpCiAgbG9jYWwgLWkgZmlyc3RMaW5lPTEKICBzaGlmdCB8fCB0cnVlCiAgKCgkIyAhPSAwKSkgfHwgcmV0dXJuIDAKCiAgbG9jYWwgYXJnCgogICMgY29udmVydCBtdWx0aS1saW5lIGFyZyB0byBzZXZlcmFsIGFyZ3MKICBsb2NhbCAtYSBhbGxBcmdzPSgpCiAgZm9yIGFyZyBpbiAiJEAiOyBkbwogICAgbG9jYWwgbGluZQogICAgbG9jYWwgSUZTPSQnXG4nCiAgICBhcmc9IiQoZWNobyAtZSAiJHthcmd9IikiCiAgICB3aGlsZSByZWFkIC1yIGxpbmU7IGRvCiAgICAgIGlmIFtbIC16ICIke2xpbmV9IiBdXTsgdGhlbgogICAgICAgIGFsbEFyZ3MrPSgkJ1xuJykKICAgICAgZWxzZQogICAgICAgIGFsbEFyZ3MrPSgiJHtsaW5lfSIpCiAgICAgIGZpCiAgICBkb25lIDw8PCIke2FyZ30iCiAgZG9uZQogIHNldCAtLSAiJHthbGxBcmdzW0BdfSIKCiAgbG9jYWwgLWkgY3VycmVudExpbmVMZW5ndGg9MAogIGxvY2FsIG5lZWRFY2hvPSIwIgogIGxvY2FsIGFyZz0iJDEiCiAgbG9jYWwgYXJnTm9BbnNpCiAgbG9jYWwgLWkgYXJnTm9BbnNpTGVuZ3RoPTAKCiAgd2hpbGUgKCgkIyA+IDApKTsgZG8KICAgIGFyZ05vQW5zaT0iJChlY2hvICIke2FyZyUlKiggKX0iIHwgRmlsdGVyczo6cmVtb3ZlQW5zaUNvZGVzKSIKICAgICgoYXJnTm9BbnNpTGVuZ3RoID0gJHsjYXJnTm9BbnNpfSkpIHx8IHRydWUKICAgIGlmICgoJCMgPCAxICYmIGFyZ05vQW5zaUxlbmd0aCA9PSAwKSk7IHRoZW4KICAgICAgYnJlYWsKICAgIGZpCiAgICBpZiBbWyAiJHthcmd9IiA9ICQnXG4nIF1dOyB0aGVuCiAgICAgIGlmIFtbICIke25lZWRFY2hvfSIgPSAiMSIgXV07IHRoZW4KICAgICAgICBuZWVkRWNobz0iMCIKICAgICAgZmkKICAgICAgZWNobyAiIgogICAgICAoKGN1cnJlbnRMaW5lTGVuZ3RoID0gMCkpIHx8IHRydWUKICAgICAgKChnbHVlTGVuZ3RoID0gMCkpIHx8IHRydWUKICAgICAgc2hpZnQgfHwgcmV0dXJuIDAKICAgICAgYXJnPSIkMSIKICAgIGVsaWYgKChhcmdOb0Fuc2lMZW5ndGggPCBtYXhMaW5lTGVuZ3RoIC0gY3VycmVudExpbmVMZW5ndGggLSBnbHVlTGVuZ3RoKSk7IHRoZW4KICAgICAgIyBhcmcgY2FuIGJlIHN0b3JlZCBhcyBhIHdob2xlIG9uIGN1cnJlbnQgbGluZQogICAgICBpZiAoKGdsdWVMZW5ndGggPiAwKSk7IHRoZW4KICAgICAgICBlY2hvIC1lIC1uICIke2dsdWV9IgogICAgICAgICgoY3VycmVudExpbmVMZW5ndGggKz0gZ2x1ZUxlbmd0aCkpCiAgICAgIGZpCiAgICAgIGlmICgoY3VycmVudExpbmVMZW5ndGggPT0gMCAmJiBmaXJzdExpbmUgPT0gMCkpOyB0aGVuCiAgICAgICAgZWNobyAtbiAiJHtpbmRlbnRTdHJ9IgogICAgICBmaQogICAgICBlY2hvIC1lIC1uICIke2FyZ30iIHwgc2VkICdzL1tcdCBdKiQvL2cnCiAgICAgIG5lZWRFY2hvPSIxIgogICAgICAoKGN1cnJlbnRMaW5lTGVuZ3RoICs9IGFyZ05vQW5zaUxlbmd0aCkpCiAgICAgICgoZ2x1ZUxlbmd0aCA9ICR7I2dsdWV9KSkgfHwgdHJ1ZQogICAgICBzaGlmdCB8fCByZXR1cm4gMAogICAgICBhcmc9IiQxIgogICAgZWxzZQogICAgICBpZiAoKGFyZ05vQW5zaUxlbmd0aCA+PSAobWF4TGluZUxlbmd0aCAtIGluZGVudE5leHRMaW5lKSkpOyB0aGVuCiAgICAgICAgaWYgKChjdXJyZW50TGluZUxlbmd0aCA9PSAwICYmIGZpcnN0TGluZSA9PSAwKSk7IHRoZW4KICAgICAgICAgIGVjaG8gLW4gIiR7aW5kZW50U3RyfSIKICAgICAgICAgICgoY3VycmVudExpbmVMZW5ndGggKz0gaW5kZW50TmV4dExpbmUpKQogICAgICAgIGZpCiAgICAgICAgIyBhcmcgY2FuIGJlIHN0b3JlZCBvbiBhIHdob2xlIGxpbmUKICAgICAgICBpZiAoKGdsdWVMZW5ndGggPiAwKSk7IHRoZW4KICAgICAgICAgIGVjaG8gLWUgLW4gIiR7Z2x1ZX0iCiAgICAgICAgICAoKGN1cnJlbnRMaW5lTGVuZ3RoICs9IGdsdWVMZW5ndGgpKQogICAgICAgIGZpCiAgICAgICAgbG9jYWwgLWkgbGVuZ3RoCiAgICAgICAgKChsZW5ndGggPSBtYXhMaW5lTGVuZ3RoIC0gY3VycmVudExpbmVMZW5ndGgpKSB8fCB0cnVlCiAgICAgICAgZWNobyAtZSAiJHthcmc6MDoke2xlbmd0aH19IiB8IHNlZCAncy9bXHQgXSokLy9nJwogICAgICAgICgoY3VycmVudExpbmVMZW5ndGggPSAwKSkgfHwgdHJ1ZQogICAgICAgICgoZ2x1ZUxlbmd0aCA9IDApKSB8fCB0cnVlCiAgICAgICAgYXJnPSIke2FyZzoke2xlbmd0aH19IgogICAgICAgIG5lZWRFY2hvPSIwIgogICAgICBlbHNlCiAgICAgICAgIyBhcmcgY2Fubm90IGJlIHN0b3JlZCBvbiBhIHdob2xlIGxpbmUsIHNvIHdlIGFkZCBpdCBvbiBuZXh0IGxpbmUgYXMgYSB3aG9sZQogICAgICAgIGVjaG8KICAgICAgICBlY2hvIC1lIC1uICIke2luZGVudFN0cn0ke2FyZ30iIHwgc2VkICdzL1tcdCBdKiQvL2cnCiAgICAgICAgKChnbHVlTGVuZ3RoID0gJHsjZ2x1ZX0pKSB8fCB0cnVlCiAgICAgICAgKChjdXJyZW50TGluZUxlbmd0aCA9IGFyZ05vQW5zaUxlbmd0aCkpCiAgICAgICAgYXJnPSIiICMgYWxsb3dzIHRvIGdvIHRvIG5leHQgYXJnCiAgICAgICAgbmVlZEVjaG89IjEiCiAgICAgIGZpCiAgICAgIGlmIFtbIC16ICIke2FyZ30iIF1dOyB0aGVuCiAgICAgICAgc2hpZnQgfHwgcmV0dXJuIDAKICAgICAgICBhcmc9IiQxIgogICAgICBmaQogICAgZmkKICAgICgoZmlyc3RMaW5lID0gMCkpIHx8IHRydWUKICBkb25lCiAgaWYgW1sgIiR7bmVlZEVjaG99IiA9ICIxIiBdXTsgdGhlbgogICAgZWNobwogIGZpCn0KCiNzZXQgLXgKI0FycmF5Ojp3cmFwICI6IiA0MCAwICJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwiICJjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQuIiAiQ3VyYWJpdHVyIGFjIGVsaXQgaWQgbWFzc2EiICJjb25kaW1lbnR1bSBmaW5pYnVzLiIKCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBlbnYgZmlsZXMgYXJlIGxvYWRlZAojIEBub2FyZ3MKIyBAZXhpdGNvZGUgMSBpZiBnZXRPcmRlcmVkQ29uZkZpbGVzIGZhaWxzCiMgQGV4aXRjb2RlIDIgaWYgb25lIG9mIGVudiBmaWxlcyBmYWlscyB0byBsb2FkCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKRW52OjpyZXF1aXJlTG9hZCgpIHsKICBsb2NhbCBjb25maWdGaWxlc1N0cgogIGNvbmZpZ0ZpbGVzU3RyPSIkKEVudjo6Z2V0T3JkZXJlZENvbmZGaWxlcykiIHx8IHJldHVybiAxCgogIGxvY2FsIC1hIGNvbmZpZ0ZpbGVzCiAgcmVhZGFycmF5IC10IGNvbmZpZ0ZpbGVzIDw8PCIke2NvbmZpZ0ZpbGVzU3RyfSIKCiAgIyBpZiBlbXB0eSBzdHJpbmcsIHRoZXJlIHdpbGwgYmUgb25lIGVsZW1lbnQKICBpZiAoKCR7I2NvbmZpZ0ZpbGVzW0BdfSA9PSAwKSkgfHwgW1sgLXogIiR7Y29uZmlnRmlsZXNTdHJ9IiBdXTsgdGhlbgogICAgIyBzaG91bGQgbm90IGhhcHBlbiwgYXMgdGhlcmUgaXMgYWx3YXlzIGRlZmF1bHQgZmlsZQogICAgTG9nOjpkaXNwbGF5U2tpcHBlZCAibm8gZW52IGZpbGUgdG8gbG9hZCIKICAgIHJldHVybiAwCiAgZmkKCiAgRW52OjptZXJnZUNvbmZGaWxlcyAiJHtjb25maWdGaWxlc1tAXX0iIHx8IHsKICAgIExvZzo6ZGlzcGxheUVycm9yICJ3aGlsZSBsb2FkaW5nIGNvbmZpZyBmaWxlczogJHtjb25maWdGaWxlc1sqXX0iCiAgICByZXR1cm4gMgogIH0KfQoKIyBAZGVzY3JpcHRpb24gbG9hZCAuZnJhbWV3b3JrLWNvbmZpZwojIEBhcmcgJDEgbG9hZGVkQ29uZmlnRmlsZTomU3RyaW5nIChwYXNzZWQgYnkgcmVmZXJlbmNlKSB0aGUgZmluYWxseSBsb2FkZWQgY29uZmlndXJhdGlvbiBmaWxlIHBhdGgKIyBAYXJnICRAIHNyY0RpcnM6U3RyaW5nW10gdGhlIHNyYyBkaXJlY3RvcmllcyBpbiB3aGljaCAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIHdpbGwgYmUgc2VhcmNoZWQKIyBAc3Rkb3V0IHRoZSBjb25maWcgZmlsZSBwYXRoIGxvYWRlZCBpZiBhbnkKIyBAZXhpdGNvZGUgMCBpZiAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIGhhcyBiZWVuIGZvdW5kIGluIHNyY0RpcnMgcHJvdmlkZWQKIyBAZXhpdGNvZGUgMSBpZiAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIG5vdCBmb3VuZAojIEBzZWUgQ29uZjo6bG9hZE5lYXJlc3RGaWxlCkZyYW1ld29yazo6bG9hZENvbmZpZygpIHsKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICBsb2NhbCAtbiBsb2FkQ29uZmlnX2xvYWRlZENvbmZpZ0ZpbGU9JDEKICBzaGlmdCB8fCB0cnVlCiAgQ29uZjo6bG9hZE5lYXJlc3RGaWxlICIuZnJhbWV3b3JrLWNvbmZpZyIgbG9hZENvbmZpZ19sb2FkZWRDb25maWdGaWxlICIkQCIKfQoKIyBAZGVzY3JpcHRpb24gTG9nIG5hbWVzcGFjZSBwcm92aWRlcyAyIGtpbmQgb2YgZnVuY3Rpb25zCiMgLSBMb2c6OmRpc3BsYXkqIGFsbG93cyB0byBkaXNwbGF5IGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gZGlzcGxheSBsZXZlbAojIC0gTG9nOjpsb2cqIGFsbG93cyB0byBsb2cgZ2l2ZW4gbWVzc2FnZSB3aXRoCiMgICBnaXZlbiBsb2cgbGV2ZWwKIyBMb2c6OmRpc3BsYXkqIGZ1bmN0aW9ucyBhdXRvbWF0aWNhbGx5IGxvZyB0aGUgbWVzc2FnZSB0b28KIyBAc2VlIEVudjo6cmVxdWlyZUxvYWQgdG8gbG9hZCB0aGUgZGlzcGxheSBhbmQgbG9nIGxldmVsIGZyb20gLmVudiBmaWxlCgojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgb2ZmCmV4cG9ydCBfX0xFVkVMX09GRj0wCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBlcnJvcgpleHBvcnQgX19MRVZFTF9FUlJPUj0xCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCB3YXJuaW5nCmV4cG9ydCBfX0xFVkVMX1dBUk5JTkc9MgojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgaW5mbwpleHBvcnQgX19MRVZFTF9JTkZPPTMKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIHN1Y2Nlc3MKZXhwb3J0IF9fTEVWRUxfU1VDQ0VTUz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBkZWJ1ZwpleHBvcnQgX19MRVZFTF9ERUJVRz00CgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIG9mZgpleHBvcnQgX19WRVJCT1NFX0xFVkVMX09GRj0wCiMgQGRlc2NyaXB0aW9uIHZlcmJvc2UgbGV2ZWwgaW5mbwpleHBvcnQgX19WRVJCT1NFX0xFVkVMX0lORk89MQojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9ERUJVRz0yCiMgQGRlc2NyaXB0aW9uIHZlcmJvc2UgbGV2ZWwgaW5mbwpleHBvcnQgX19WRVJCT1NFX0xFVkVMX1RSQUNFPTMKCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBkZWJ1ZyBjb2xvciAoZ3JleSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpkaXNwbGF5RGVidWcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfREVCVUcpKTsgdGhlbgogICAgZWNobyAtZSAiJHtfX0RFQlVHX0NPTE9SfURFQlVHICAgLSAkezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ0RlYnVnICIkMSIKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGVycm9yIGNvbG9yIChyZWQpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheUVycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0VSUk9SKSk7IHRoZW4KICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gJHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dFcnJvciAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBpbmZvIGNvbG9yIChiZyBsaWdodCBibHVlL2ZnIHdoaXRlKQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmRpc3BsYXlJbmZvKCkgewogIGxvY2FsIHR5cGU9IiR7MjotSU5GT30iCiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBlY2hvIC1lICIke19fSU5GT19DT0xPUn0ke3R5cGV9ICAgIC0gJHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dJbmZvICIkMSIgIiR7dHlwZX0iCn0KCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyB3YXJuaW5nIGNvbG9yICh5ZWxsb3cpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6ZGlzcGxheVdhcm5pbmcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfV0FSTklORykpOyB0aGVuCiAgICBlY2hvIC1lICIke19fV0FSTklOR19DT0xPUn1XQVJOICAgIC0gJHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dXYXJuaW5nICIkMSIKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGVycm9yIGNvbG9yIChyZWQpIGFuZCBleGl0IGltbWVkaWF0ZWx5IHdpdGggZXJyb3Igc3RhdHVzIDEKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpmYXRhbCgpIHsKICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RkFUQUwgICAtICR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBMb2c6OmxvZ0ZhdGFsICIkMSIKICBleGl0IDEKfQoKIyBAZGVzY3JpcHRpb24gYWN0aXZhdGUgb3Igbm90IExvZzo6ZGlzcGxheSogYW5kIExvZzo6bG9nKiBmdW5jdGlvbnMKIyBiYXNlZCBvbiBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMIGFuZCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwKIyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgbG9hZGVkIGJ5IEVudjo6cmVxdWlyZUxvYWQKIyB0cnkgdG8gY3JlYXRlIGxvZyBmaWxlIGFuZCByb3RhdGUgaXQgaWYgbmVjZXNzYXJ5CiMgQG5vYXJncwojIEBzZXQgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMIGludCB0byBPRkYgbGV2ZWwgaWYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUgaXMgZW1wdHkgb3Igbm90IHdyaXRhYmxlCiMgQGVudiBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMIGludAojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMIGludAojIEBlbnYgQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUgU3RyaW5nCiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT04gaW50IGRvIGxvZyByb3RhdGlvbiBpZiA+IDAKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gYWJvdXQgbG9nIGZpbGUgaXMgZGlzcGxheWVkCiMgQHJlcXVpcmUgRW52OjpyZXF1aXJlTG9hZAojIEByZXF1aXJlIFVJOjpyZXF1aXJlVGhlbWUKTG9nOjpyZXF1aXJlTG9hZCgpIHsKICBpZiBbWyAteiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRTotfSIgXV07IHRoZW4KICAgIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke19fTEVWRUxfT0ZGfQogICAgZXhwb3J0IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTAogIGZpCgogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgaWYgW1sgISAtZiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dOyB0aGVuCiAgICAgIGlmCiAgICAgICAgISBta2RpciAtcCAiJChkaXJuYW1lICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIpIiAyPi9kZXYvbnVsbCB8fAogICAgICAgICAgISB0b3VjaCAtLW5vLWNyZWF0ZSAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIDI+L2Rldi9udWxsCiAgICAgIHRoZW4KICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtIEZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgIGZpCiAgICBlbGlmIFtbICEgLXcgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgZmkKCiAgZmkKCiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPiBfX0xFVkVMX09GRikpOyB0aGVuCiAgICAjIHdpbGwgYWx3YXlzIGJlIGNyZWF0ZWQgZXZlbiBpZiBub3QgaW4gaW5mbyBsZXZlbAogICAgTG9nOjpsb2dNZXNzYWdlICJJTkZPIiAiTG9nZ2luZyB0byBmaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IC0gTG9nIGxldmVsICR7QkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMfSIKICAgIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OID4gMCkpOyB0aGVuCiAgICAgIExvZzo6cm90YXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OfSIKICAgIGZpCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gZHJhdyBhIGxpbmUgd2l0aCB0aGUgY2hhcmFjdGVyIHBhc3NlZCBpbiBwYXJhbWV0ZXIgcmVwZWF0ZWQgZGVwZW5kaW5nIG9uIHRlcm1pbmFsIHdpZHRoCiMgQGFyZyAkMSBjaGFyYWN0ZXI6U3RyaW5nIGNoYXJhY3RlciB0byB1c2UgYXMgc2VwYXJhdG9yIChkZWZhdWx0IHZhbHVlICMpClVJOjpkcmF3TGluZSgpIHsKICBsb2NhbCBjaGFyYWN0ZXI9IiR7MTotI30iCiAgcHJpbnRmICclKnNcbicgIiR7Q09MVU1OUzotJChbWyAtdCAwIF1dICYmIHRwdXQgY29scyB8fCBlY2hvKX0iICcnIHwgdHIgJyAnICIke2NoYXJhY3Rlcn0iCn0KCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3JzIHRoZW1lIGNvbnN0YW50cwojIEB3YXJuaW5nIGlmIHR0eSBub3Qgb3BlbmVkLCBub0NvbG9yIHRoZW1lIHdpbGwgYmUgY2hvc2VuCiMgQGFyZyAkMSB0aGVtZTpTdHJpbmcgdGhlIHRoZW1lIHRvIHVzZSAoZGVmYXVsdCwgbm9Db2xvcikKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10KIyBAc2V0IF9fRVJST1JfQ09MT1IgU3RyaW5nIGluZGljYXRlIGVycm9yIHN0YXR1cwojIEBzZXQgX19JTkZPX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBpbmZvIHN0YXR1cwojIEBzZXQgX19TVUNDRVNTX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBzdWNjZXNzIHN0YXR1cwojIEBzZXQgX19XQVJOSU5HX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSB3YXJuaW5nIHN0YXR1cwojIEBzZXQgX19TS0lQUEVEX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBza2lwcGVkIHN0YXR1cwojIEBzZXQgX19ERUJVR19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgZGVidWcgc3RhdHVzCiMgQHNldCBfX0hFTFBfQ09MT1IgU3RyaW5nIGluZGljYXRlIGhlbHAgc3RhdHVzCiMgQHNldCBfX1RFU1RfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX1RFU1RfRVJST1JfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX0hFTFBfVElUTEVfQ09MT1IgU3RyaW5nIHVzZWQgdG8gZGlzcGxheSBoZWxwIHRpdGxlIGluIGhlbHAgc3RyaW5ncwojIEBzZXQgX19IRUxQX09QVElPTl9DT0xPUiBTdHJpbmcgdXNlZCB0byBkaXNwbGF5IGhpZ2hsaWdodCBvcHRpb25zIGluIGhlbHAgc3RyaW5ncwojCiMgQHNldCBfX1JFU0VUX0NPTE9SIFN0cmluZyByZXNldCBkZWZhdWx0IGNvbG9yCiMKIyBAc2V0IF9fSEVMUF9FWEFNUExFIFN0cmluZyB0byByZW1vdmUKIyBAc2V0IF9fSEVMUF9USVRMRSBTdHJpbmcgdG8gcmVtb3ZlCiMgQHNldCBfX0hFTFBfTk9STUFMIFN0cmluZyB0byByZW1vdmUKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClVJOjp0aGVtZSgpIHsKICBsb2NhbCB0aGVtZT0iJHsxLWRlZmF1bHR9IgogIGlmIFtbICEgIiR7dGhlbWV9IiA9fiAtZm9yY2UkIF1dICYmICEgQXNzZXJ0Ojp0dHk7IHRoZW4KICAgIHRoZW1lPSJub0NvbG9yIgogIGZpCiAgY2FzZSAiJHt0aGVtZX0iIGluCiAgICBkZWZhdWx0IHwgZGVmYXVsdC1mb3JjZSkKICAgICAgdGhlbWU9ImRlZmF1bHQiCiAgICAgIDs7CiAgICBub0NvbG9yKSA7OwogICAgKikKICAgICAgTG9nOjpmYXRhbCAiaW52YWxpZCB0aGVtZSBwcm92aWRlZCIKICAgICAgOzsKICBlc2FjCiAgaWYgW1sgIiR7dGhlbWV9IiA9ICJkZWZhdWx0IiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfVEhFTUU9ImRlZmF1bHQiCiAgICAjIGNoZWNrIGNvbG9ycyBhcHBsaWNhYmxlIGh0dHBzOi8vbWlzYy5mbG9naXNvZnQuY29tL2Jhc2gvdGlwX2NvbG9yc19hbmRfZm9ybWF0dGluZwogICAgX19FUlJPUl9DT0xPUj0nXGVbMzFtJyAgICAgICAgICMgUmVkCiAgICBfX0lORk9fQ09MT1I9J1xlWzQ0bScgICAgICAgICAgIyB3aGl0ZSBvbiBsaWdodEJsdWUKICAgIF9fU1VDQ0VTU19DT0xPUj0nXGVbMzJtJyAgICAgICAjIEdyZWVuCiAgICBfX1dBUk5JTkdfQ09MT1I9J1xlWzMzbScgICAgICAgIyBZZWxsb3cKICAgIF9fU0tJUFBFRF9DT0xPUj0nXGVbMzNtJyAgICAgICAjIFllbGxvdwogICAgX19ERUJVR19DT0xPUj0nXGVbMzdtJyAgICAgICAgICMgR3JleQogICAgX19IRUxQX0NPTE9SPSdcZVs3OzQ5OzMzbScgICAgICMgQmxhY2sgb24gR29sZAogICAgX19URVNUX0NPTE9SPSdcZVsxMDBtJyAgICAgICAgICMgTGlnaHQgbWFnZW50YQogICAgX19URVNUX0VSUk9SX0NPTE9SPSdcZVs0MW0nICAgICMgd2hpdGUgb24gcmVkCiAgICBfX0hFTFBfVElUTEVfQ09MT1I9IlxlWzE7MzdtIiAgIyBCb2xkCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPSJcZVsxOzM0bSIgIyBCbHVlCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nXGVbMG0nICMgUmVzZXQgQ29sb3IKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9FWEFNUExFPSIkKGVjaG8gLWUgIlxlWzI7OTdtIikiCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfVElUTEU9IiQoZWNobyAtZSAiXGVbMTszN20iKSIKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9OT1JNQUw9IiQoZWNobyAtZSAiXDAzM1swbSIpIgogIGVsc2UKICAgIEJBU0hfRlJBTUVXT1JLX1RIRU1FPSJub0NvbG9yIgogICAgIyBjaGVjayBjb2xvcnMgYXBwbGljYWJsZSBodHRwczovL21pc2MuZmxvZ2lzb2Z0LmNvbS9iYXNoL3RpcF9jb2xvcnNfYW5kX2Zvcm1hdHRpbmcKICAgIF9fRVJST1JfQ09MT1I9JycKICAgIF9fSU5GT19DT0xPUj0nJwogICAgX19TVUNDRVNTX0NPTE9SPScnCiAgICBfX1dBUk5JTkdfQ09MT1I9JycKICAgIF9fU0tJUFBFRF9DT0xPUj0nJwogICAgX19ERUJVR19DT0xPUj0nJwogICAgX19IRUxQX0NPTE9SPScnCiAgICBfX1RFU1RfQ09MT1I9JycKICAgIF9fVEVTVF9FUlJPUl9DT0xPUj0nJwogICAgX19IRUxQX1RJVExFX0NPTE9SPScnCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPScnCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nJwogICAgX19IRUxQX0VYQU1QTEU9JycKICAgIF9fSEVMUF9USVRMRT0nJwogICAgX19IRUxQX05PUk1BTD0nJwogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBDT01NQU5EX0JJTl9ESVIgZW52IHZhciBpcyBzZXQKIyBhbmQgUEFUSCBjb3JyZWN0bHkgcHJlcGFyZWQKIyBAbm9hcmdzCiMgQHNldCBDT01NQU5EX0JJTl9ESVIgc3RyaW5nIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdG8gZmluZCB0aGlzIGNvbW1hbmQKIyBAc2V0IFBBVEggc3RyaW5nIGFkZCBkaXJlY3Rvcnkgd2hlcmUgdG8gZmluZCB0aGlzIGNvbW1hbmQgYmluYXJ5CkNvbXBpbGVyOjpGYWNhZGU6OnJlcXVpcmVDb21tYW5kQmluRGlyKCkgewogIENPTU1BTkRfQklOX0RJUj0iJHtDVVJSRU5UX0RJUn0iCiAgRW52OjpwYXRoUHJlcGVuZCAiJHtDT01NQU5EX0JJTl9ESVJ9Igp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiB0dHkgKGludGVyYWN0aXZlIG1vZGUpIGlzIGFjdGl2ZQojIEBub2FyZ3MKIyBAZXhpdGNvZGUgMSBpZiB0dHkgbm90IGFjdGl2ZQojIEBlbnYgTk9OX0lOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgbm90IGludGVyYWN0aXZlIGV2ZW4gaWYgZW52aXJvbm1lbnQgaXMgaW50ZXJhY3RpdmUKIyBAZW52IElOVEVSQUNUSVZFIGlmIDEgY29uc2lkZXIgYXMgaW50ZXJhY3RpdmUgZXZlbiBpZiBlbnZpcm9ubWVudCBpcyBub3QgaW50ZXJhY3RpdmUKIyBAc3RkZXJyIGRpYWdub3N0aWMgaW5mb3JtYXRpb24gKyBoZWxwIGlmIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZApBc3NlcnQ6OnR0eSgpIHsKICBpZiBbWyAiJHtOT05fSU5URVJBQ1RJVkU6LTB9IiA9ICIxIiBdXTsgdGhlbgogICAgcmV0dXJuIDEKICBmaQogIGlmIFtbICIke0lOVEVSQUNUSVZFOi0wfSIgPSAiMSIgXV07IHRoZW4KICAgIHJldHVybiAwCiAgZmkKICBbWyAtdCAxIHx8IC10IDIgXV0KfQoKIyBAZGVzY3JpcHRpb24gTG9hZCB0aGUgbmVhcmVzdCBjb25maWcgZmlsZQojIGluIG5leHQgZXhhbXBsZSB3aWxsIHNlYXJjaCBmaXJzdCAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIGluICJzcmNEaXIxIgojIHRoZW4gaWYgbm90IGZvdW5kIHdpbGwgZ28gaW4gdXAgZGlyZWN0b3JpZXMgdW50aWwgLwojIHRoZW4gd2lsbCBzZWFyY2ggaW4gInNyY0RpcjIiCiMgdGhlbiBpZiBub3QgZm91bmQgd2lsbCBnbyBpbiB1cCBkaXJlY3RvcmllcyB1bnRpbCAvCiMgc291cmNlIHRoZSBmaWxlIGlmIGZvdW5kCiMgQGV4YW1wbGUKIyAgIENvbmY6OmxvYWROZWFyZXN0RmlsZSAiLmZyYW1ld29yay1jb25maWciICJzcmNEaXIxIiAic3JjRGlyMiIKIwojIEBhcmcgJDEgY29uZmlnRmlsZU5hbWU6U3RyaW5nIGNvbmZpZyBmaWxlIG5hbWUgdG8gc2VhcmNoCiMgQGFyZyAkMiBsb2FkZWRGaWxlOlN0cmluZyAocGFzc2VkIGJ5IHJlZmVyZW5jZSkgd2lsbCByZXR1cm4gdGhlIGxvYWRlZCBjb25maWcgZmlsZSBuYW1lCiMgQGFyZyAkQCBzcmNEaXJzOlN0cmluZ1tdIHNvdXJjZSBkaXJlY3RvcmllcyBpbiB3aGljaCB0aGUgY29uZmlnIGZpbGUgd2lsbCBiZSBzZWFyY2hlZAojIEBleGl0Y29kZSAwIGlmIGZpbGUgZm91bmQKIyBAZXhpdGNvZGUgMSBpZiBmaWxlIG5vdCBmb3VuZApDb25mOjpsb2FkTmVhcmVzdEZpbGUoKSB7CiAgbG9jYWwgY29uZmlnRmlsZU5hbWU9IiQxIgogIGxvY2FsIC1uIGxvYWRlZEZpbGU9IiQyIgogIHNoaWZ0IDIgfHwgdHJ1ZQogIGxvY2FsIC1hIHNyY0RpcnM9KCIkQCIpCiAgZm9yIHNyY0RpciBpbiAiJHtzcmNEaXJzW0BdfSI7IGRvCiAgICBjb25maWdGaWxlPSIkKEZpbGU6OnVwRmluZCAiJHtzcmNEaXJ9IiAiJHtjb25maWdGaWxlTmFtZX0iIHx8IHRydWUpIgogICAgaWYgW1sgLW4gIiR7Y29uZmlnRmlsZX0iIF1dOyB0aGVuCiAgICAgICMgc2hlbGxjaGVjayBzb3VyY2U9Ly5mcmFtZXdvcmstY29uZmlnCiAgICAgIHNvdXJjZSAiJHtjb25maWdGaWxlfSIgfHwgTG9nOjpmYXRhbCAiZXJyb3Igd2hpbGUgbG9hZGluZyBjb25maWcgZmlsZSAnJHtjb25maWdGaWxlfSciCiAgICAgIExvZzo6ZGlzcGxheURlYnVnICJDb25maWcgZmlsZSAke2NvbmZpZ0ZpbGV9IGlzIGxvYWRlZCIKICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgIGxvYWRlZEZpbGU9IiR7Y29uZmlnRmlsZX0iCiAgICAgIHJldHVybiAwCiAgICBmaQogIGRvbmUKCiAgTG9nOjpkaXNwbGF5V2FybmluZyAiQ29uZmlnIGZpbGUgJyR7Y29uZmlnRmlsZU5hbWV9JyBub3QgZm91bmQgaW4gYW55IHNvdXJjZSBkaXJlY3RvcmllcyBwcm92aWRlZCIKICByZXR1cm4gMQp9CgojIEBkZXNjcmlwdGlvbiBnZXQgbGlzdCBvZiBlbnYgZmlsZXMgdG8gbG9hZAojIGluIG9yZGVyIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgZm9yIEVudjo6cmVxdWlyZUxvYWQKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0VOVl9GSUxFUyBTdHJpbmdbXSBsaXN0IG9mIGVudiBmaWxlcyB0aGF0IHNob3VsZCBiZSBsb2FkZWQKIyBAZXhpdGNvZGUgMSBpZiBvbmUgb2YgdGhlIGVudiBmaWxlIGNhbm5vdCBiZSBnZW5lcmF0ZWQKIyBAZXhpdGNvZGUgMiBpZiBvbmUgb2YgdGhlIGVudiBmaWxlIGlzIG5vdCBhIGZpbGUgb3IgcmVhZGFibGUKIyBAc3Rkb3V0IHRoZSBlbnYgZmlsZXMgYXNrZWQgdG8gYmUgbG9hZGVkCiMgQHN0ZGVyciBkaWFnbm9zdGljIGluZm9ybWF0aW9uIG9uIGZhaWx1cmUKIyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtdG9vbHMtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL0ZyYW1ld29ya0RvYy5tZCNjb25maWdfZmlsZV9vcmRlcgpFbnY6OmdldE9yZGVyZWRDb25mRmlsZXMoKSB7CiAgbG9jYWwgLWEgY29uZmlnRmlsZXM9KCkKCiAgaWYgW1sgLW4gIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTWzBdKzF9IiBdXTsgdGhlbgogICAgIyBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMgaXMgYW4gYXJyYXkKICAgIGNvbmZpZ0ZpbGVzKz0oIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTW0BdfSIpCiAgZmkKCiAgbG9jYWwgZGVmYXVsdEVudkZpbGUKICBkZWZhdWx0RW52RmlsZT0iJChFbnY6OmNyZWF0ZURlZmF1bHRFbnZGaWxlKSIgfHwgcmV0dXJuIDEKICBjb25maWdGaWxlcys9KCIke2RlZmF1bHRFbnZGaWxlfSIpCgogIGxvY2FsIGZpbGUKICBmb3IgZmlsZSBpbiAiJHtjb25maWdGaWxlc1tAXX0iOyBkbwogICAgaWYgW1sgISAtZiAiJHtmaWxlfSIgfHwgISAtciAiJHtmaWxlfSIgXV07IHRoZW4KICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIk9uZSBvZiB0aGUgY29uZmlnIGZpbGUgaXMgbm90IGF2YWlsYWJsZSAnJHtmaWxlfSciCiAgICAgIHJldHVybiAyCiAgICBmaQogICAgZWNobyAiJHtmaWxlfSIKICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIG1lcmdlIGFuZCBsb2FkIGNvbmYgZmlsZXMgc3BlY2lmaWVkIGFzIGFyZ3VtZW50CiMgLSBmaWxlcyBhcmUgY2xlYW5lZCBmcm9tIGF5IGNvbW1lbnQKIyAtIG1pc3NpbmcgcXVvdGVzIGFmdGVyIHByb3BlcnR5ID0gc2lnbiBhcmUgYWRkZWQgYXV0b21hdGljYWxseQojIC0gYXV0b21hdGljIHJlbW92ZSBvZiBhbGwgd2hpdGVzcGFjZSBiZWZvcmUgYW5kIGFmdGVyIGRlY2xhcmF0aW9ucwojIC0gYmFzaCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQKIyAtIGlmIGEgdmFyaWFibGUgaXMgZGVjbGFyZWQgaW4gZmlyc3QgZmlsZSBhbmQgb3ZlcnJpZGRlbiBsYXRlciBvbgojICAgaW4gdGhlIHNhbWUgZmlsZSBvciBpbiBzdWJzZXF1ZW50IGZpbGVzLCB0aG9zZSBvdmVybG9hZHMgd2lsbCBiZQojICAgaWdub3JlZAojIEB3YXJuaW5nIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSBsb2FkaW5nIG9uZSBvZiB0aGUgY29uZmlnIGZpbGUsIGV4aXQgY29kZSAzIGJ1dCBlbnZpcm9ubWVudCBjb3VsZCBiZSBwYXJ0aWFsbHkgbG9hZGVkCiMgQGFyZyAkQCBhcmdzOlN0cmluZ1tdIGxpc3Qgb2YgY29uZmlndXJhdGlvbiBmaWxlcyB0byBsb2FkIGluIG9yZGVyCiMgQHNldCBlbnZWYXJzIFN0cmluZyB3aWxsIHNldCBpbiBlbnZpcm9ubWVudCBhbGwgdGhlIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBpbiB0aGUgY29uZmlnIGZpbGVzCiMgQGVudiBlbnZWYXJzIFN0cmluZyB0aGUgZW52IHZhcmlhYmxlcyBvZiB0aGUgY3VycmVudCBzY3JpcHQgY291bGQgYmUgdXNlZCB0byBpbnRlcnByZXQgdmFyaWFibGVzIGR1cmluZyBjb25maWcgZmlsZXMgcGFyc2luZwojIEBleGl0Y29kZSAwIGlmIG5vIGNvbmZpZyBmaWxlcyBwcm92aWRlZCBvciBsb2FkIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkKIyBAZXhpdGNvZGUgMSBpZiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZyB0aGUgY29uZmlnIGZpbGVzIChmaWxlIG5vdCBmb3VuZCwgZ3JlcCwgYXdrIG9yIHNlZCBlcnJvcikKIyBAZXhpdGNvZGUgMiBpZiB0ZW1wb3JhcnkgZmlsZSBjYW5ub3QgYmUgY3JlYXRlZAojIEBleGl0Y29kZSAzIGlmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBjb25maWcgZmlsZSBzb3VyY2luZwojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgQHNlZSBsYXJnZWx5IGluc3BpcmVkIGJ1dCBtb2RpZmllZCBmcm9tIGh0dHBzOi8vb3BlbnNvdXJjZS5jb20vYXJ0aWNsZS8yMS81L3Byb2Nlc3NpbmctY29uZmlndXJhdGlvbi1maWxlcy1zaGVsbApFbnY6Om1lcmdlQ29uZkZpbGVzKCkgewogIGxvY2FsIC1hIGNvbmZpZ0ZpbGVMaXN0PSgiJEAiKQoKICBpZiAoKCR7I2NvbmZpZ0ZpbGVMaXN0W0BdfSA9PSAwKSk7IHRoZW4KICAgIHJldHVybiAwCiAgZmkKCiAgbG9jYWwgY29tYmluZWRDb25maWdGaWxlCiAgY29tYmluZWRDb25maWdGaWxlPSIkKEZyYW1ld29yazo6Y3JlYXRlVGVtcEZpbGUgIm1lcmdlQ29uZkZpbGVzIikiIHx8IHJldHVybiAyCgogICgKICAgICMgcmVtb3ZlcyBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIGVhY2ggZmlsZSwgaWYgYW55CiAgICAjIHRoaXMgaXMgYWJzb2x1dGVseSByZXF1aXJlZCB3aGVuIGltcG9ydGluZyBpbnRvIENvbmZpZ01hcHMKICAgICMgcHV0IHF1b3RlcyBhcm91bmQgdmFsdWVzCiAgICBzZWQgLUUgLWUgJCdzL1xzKiQvLyA7IC9eJC9kIDsgL14jLiokL2QgOyBzLz0oW14iXCddLiopJC89IlxcMSIvJyAiJHtjb25maWdGaWxlTGlzdFtAXX0iIHwKICAgICAgIyByZW1vdmUgYWxsIGNvbW1lbnQgbGluZXMKICAgICAgRmlsdGVyczo6Y29tbWVudExpbmVzIHwKICAgICAgIyBpdGVyYXRlcyBvdmVyIGVhY2ggZmlsZSBhbmQgcHJpbnRzIChkZWZhdWx0IGF3ayBiZWhhdmlvcikKICAgICAgIyBlYWNoIHVuaXF1ZSBsaW5lOyBvbmx5IHRha2VzIGZpcnN0IHZhbHVlIGFuZCBpZ25vcmVzIGR1cGxpY2F0ZXMKICAgICAgYXdrIC1GPSAnIWxpbmVbJDFdKysnCiAgKSA+IiR7Y29tYmluZWRDb25maWdGaWxlfSIgfHwgcmV0dXJuIDEKCiAgIyBoYXZlIHRvIGV4cG9ydCBldmVyeXRoaW5nLCBhbmQgc291cmNlIGl0IHR3aWNlOgogICMgMSkgZmlyc3Qgc291cmNlIGlzIHRvIHJlYWxpemUgdmFyaWFibGVzCiAgIyAyKSBzZWNvbmQgdGltZSBpcyB0byByZWFsaXplIHJlZmVyZW5jZXMKICBzZXQgLW8gYWxsZXhwb3J0CiAgIyBzaGVsbGNoZWNrIHNvdXJjZT0uZnJhbWV3b3JrLWNvbmZpZwogIHNvdXJjZSAiJHtjb21iaW5lZENvbmZpZ0ZpbGV9IiB8fCByZXR1cm4gMwogICMgc2hlbGxjaGVjayBzb3VyY2U9LmZyYW1ld29yay1jb25maWcKICBzb3VyY2UgIiR7Y29tYmluZWRDb25maWdGaWxlfSIgfHwgcmV0dXJuIDMKICBzZXQgK28gYWxsZXhwb3J0Cn0KCiMgQGRlc2NyaXB0aW9uIHByZXBlbmQgZGlyZWN0b3JpZXMgdG8gdGhlIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10gbGlzdCBvZiBkaXJlY3RvcmllcyB0byBwcmVwZW5kCiMgQHNldCBQQVRIIHVwZGF0ZSBQQVRIIHdpdGggdGhlIGRpcmVjdG9yaWVzIHByZXBlbmRlZApFbnY6OnBhdGhQcmVwZW5kKCkgewogIGxvY2FsIGFyZwogIGZvciBhcmcgaW4gIiRAIjsgZG8KICAgIGlmIFtbIC1kICIke2FyZ30iICYmICI6JHtQQVRIfToiICE9ICoiOiR7YXJnfToiKiBdXTsgdGhlbgogICAgICBQQVRIPSIkKHJlYWxwYXRoICIke2FyZ30iKToke1BBVEh9IgogICAgZmkKICBkb25lCn0KCiMgQGRlc2NyaXB0aW9uIHJlbW92ZSBhbnNpIGNvZGVzIGZyb20gaW5wdXQgb3IgZmlsZXMgZ2l2ZW4gYXMgYXJndW1lbnQKIyBAYXJnICRAIGZpbGVzOlN0cmluZ1tdIHRoZSBmaWxlcyB0byBmaWx0ZXIKIyBAZXhpdGNvZGUgKiBpZiBvbmUgb2YgdGhlIGZpbHRlciBjb21tYW5kIGZhaWxzCiMgQHN0ZGluIHlvdSBjYW4gdXNlIHN0ZGluIGFzIGFsdGVybmF0aXZlIHRvIGZpbGVzIGFyZ3VtZW50CiMgQHN0ZG91dCB0aGUgZmlsdGVyZWQgY29udGVudAojIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxMjAKRmlsdGVyczo6cmVtb3ZlQW5zaUNvZGVzKCkgewogICMgY3NwZWxsOmRpc2FibGUKICBzZWQgLUUgJ3MvXHgxYlxbWzAtOTtdKlttR0tIRl0vL2cnICIkQCIKICAjIGNzcGVsbDplbmFibGUKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIHNraXAgY29sb3IgKHllbGxvdykKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpkaXNwbGF5U2tpcHBlZCgpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgPj0gX19MRVZFTF9JTkZPKSk7IHRoZW4KICAgIGVjaG8gLWUgIiR7X19TS0lQUEVEX0NPTE9SfVNLSVBQRUQgLSAkezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ1NraXBwZWQgIiQxIgp9CgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nRGVidWcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9ERUJVRykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotREVCVUd9IiAiJDEiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0Vycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpsb2dNZXNzYWdlICIkezI6LUVSUk9SfSIgIiQxIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dGYXRhbCgpIHsKICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRkFUQUx9IiAiJDEiCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dJbmZvKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotSU5GT30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBJbnRlcm5hbDogY29tbW9uIGxvZyBtZXNzYWdlCiMgQGV4YW1wbGUgdGV4dAojICAgW2RhdGVdfFtsZXZlbE1zZ118bWVzc2FnZQojCiMgQGV4YW1wbGUgdGV4dAojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxFUlJPUiAgfGxvZyBlcnJvcgojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxTS0lQUEVEfGxvZyBza2lwcGVkCiMKIyBAYXJnICQxIGxldmVsTXNnOlN0cmluZyBtZXNzYWdlJ3MgbGV2ZWwgZGVzY3JpcHRpb24gKGVnOiBTVEFUVVMsIEVSUk9SLCAuLi4pCiMgQGFyZyAkMiBtc2c6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZyBsb2cgZmlsZSB0byB1c2UsIGRvIG5vdGhpbmcgaWYgZW1wdHkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgbG9nIGxldmVsIGxvZyBvbmx5IGlmID4gT0ZGIG9yIGZhdGFsIG1lc3NhZ2VzCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBFbnY6OnJlcXVpcmVMb2FkCiMgQHJlcXVpcmUgTG9nOjpyZXF1aXJlTG9hZApMb2c6OmxvZ01lc3NhZ2UoKSB7CiAgbG9jYWwgbGV2ZWxNc2c9IiQxIgogIGxvY2FsIG1zZz0iJDIiCiAgbG9jYWwgZGF0ZQoKICBpZiBbWyAtbiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dICYmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgZGF0ZT0iJChkYXRlICcrJVktJW0tJWQgJUg6JU06JVMnKSIKICAgIHRvdWNoICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIKICAgIHByaW50ZiAiJXN8JTdzfCVzXG4iICIke2RhdGV9IiAiJHtsZXZlbE1zZ30iICIke21zZ30iID4+IiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dXYXJuaW5nKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfV0FSTklORykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotV0FSTklOR30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBUbyBiZSBjYWxsZWQgYmVmb3JlIGxvZ2dpbmcgaW4gdGhlIGxvZyBmaWxlCiMgQGFyZyAkMSBmaWxlOnN0cmluZyBsb2cgZmlsZSBuYW1lCiMgQGFyZyAkMiBtYXhMb2dGaWxlc0NvdW50OmludCBtYXhpbXVtIG51bWJlciBvZiBsb2cgZmlsZXMKTG9nOjpyb3RhdGUoKSB7CiAgbG9jYWwgZmlsZT0iJDEiCiAgbG9jYWwgbWF4TG9nRmlsZXNDb3VudD0iJHsyOi01fSIKCiAgaWYgW1sgISAtZiAiJHtmaWxlfSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheVNraXBwZWQgIkxvZyBmaWxlICR7ZmlsZX0gZG9lc24ndCBleGlzdCB5ZXQiCiAgICByZXR1cm4gMAogIGZpCiAgZm9yIGkgaW4gJChzZXEgJCgobWF4TG9nRmlsZXNDb3VudCAtIDEpKSAtMSAxKTsgZG8KICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9LiR7aX0gdG8gJHtmaWxlfS4kKChpICsgMSkpIgogICAgbXYgIiR7ZmlsZX0uInsiJHtpfSIsIiQoKGkgKyAxKSkifSAmPi9kZXYvbnVsbCB8fCB0cnVlCiAgZG9uZQogIGlmIGNwICIke2ZpbGV9IiAiJHtmaWxlfS4xIiAmPi9kZXYvbnVsbDsgdGhlbgogICAgZWNobyA+IiR7ZmlsZX0iICMgcmVzZXQgbG9nIGZpbGUKICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9IHRvICR7ZmlsZX0uMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2FkIGNvbG9yIHRoZW1lCiMgQG5vYXJncwojIEBlbnYgQkFTSF9GUkFNRVdPUktfVEhFTUUgU3RyaW5nIHRoZW1lIHRvIHVzZQojIEBleGl0Y29kZSAwIGFsd2F5cyBzdWNjZXNzZnVsClVJOjpyZXF1aXJlVGhlbWUoKSB7CiAgVUk6OnRoZW1lICIke0JBU0hfRlJBTUVXT1JLX1RIRU1FLWRlZmF1bHR9Igp9CgojIEBkZXNjcmlwdGlvbiBkZWZhdWx0IGVudiBmaWxlIHdpdGggYWxsIGRlZmF1bHQgdmFsdWVzCiMgQHN0ZG91dCB0aGUgZGVmYXVsdCBlbnYgZmlsZXBhdGgKRW52OjpjcmVhdGVEZWZhdWx0RW52RmlsZSgpIHsKICBsb2NhbCBlbnZGaWxlCiAgZW52RmlsZT0iJChGcmFtZXdvcms6OmNyZWF0ZVRlbXBGaWxlICJjcmVhdGVEZWZhdWx0RW52RmlsZUVudkZpbGUiKSIgfHwgcmV0dXJuIDIKCiAgKAogICAgZWNobyAiQkFTSF9GUkFNRVdPUktfVEhFTUU9JHtCQVNIX0ZSQU1FV09SS19USEVNRTotZGVmYXVsdH0iCiAgICBlY2hvICJCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw6LTB9IgogICAgZWNobyAiQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTD0ke0JBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUw6LSR7X19MRVZFTF9XQVJOSU5HfX0iCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMTYKICAgIGVjaG8gJ0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFPSIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFOi0iJHtGUkFNRVdPUktfUk9PVF9ESVJ9L2xvZ3MvJHtTQ1JJUFRfTkFNRX0ubG9nIn0iJwogICAgZWNobyAiQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OPSR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OOi01fSIKICApID4iJHtlbnZGaWxlfSIKICBlY2hvICIke2VudkZpbGV9Igp9CgojIEBkZXNjcmlwdGlvbiBzZWFyY2ggYSBmaWxlIGluIHBhcmVudCBkaXJlY3RvcmllcwojCiMgQGFyZyAkMSBmcm9tUGF0aDpTdHJpbmcgcGF0aAojIEBhcmcgJDIgZmlsZU5hbWU6U3RyaW5nCiMgQGFyZyAkMyB1bnRpbEluY2x1c2l2ZVBhdGg6U3RyaW5nIChvcHRpb25hbCkgZmluZCBmb3IgZ2l2ZW4gZmlsZSB1bnRpbCByZWFjaGluZyB0aGlzIGZvbGRlciAoZGVmYXVsdCB2YWx1ZTogLykKIyBAYXJnICRAIHVudGlsSW5jbHVzaXZlUGF0aHM6U3RyaW5nW10gbGlzdCBvZiB1bnRpbEluY2x1c2l2ZVBhdGgKIyBAc3Rkb3V0IFRoZSBmaWxlbmFtZSBpZiBmb3VuZAojIEBleGl0Y29kZSAxIGlmIHRoZSBjb21tYW5kIGZhaWxlZCBvciBmaWxlIG5vdCBmb3VuZApGaWxlOjp1cEZpbmQoKSB7CiAgbG9jYWwgZnJvbVBhdGg9IiQxIgogIHNoaWZ0IHx8IHRydWUKICBsb2NhbCBmaWxlTmFtZT0iJDEiCiAgc2hpZnQgfHwgdHJ1ZQogIGxvY2FsIHVudGlsSW5jbHVzaXZlUGF0aD0iJHsxOi0vfSIKICBzaGlmdCB8fCB0cnVlCgogIGlmIFtbIC1mICIke2Zyb21QYXRofSIgXV07IHRoZW4KICAgIGZyb21QYXRoPSIkKGRpcm5hbWUgIiR7ZnJvbVBhdGh9IikiCiAgZmkKICB3aGlsZSB0cnVlOyBkbwogICAgaWYgW1sgLWYgIiR7ZnJvbVBhdGh9LyR7ZmlsZU5hbWV9IiBdXTsgdGhlbgogICAgICBlY2hvICIke2Zyb21QYXRofS8ke2ZpbGVOYW1lfSIKICAgICAgcmV0dXJuIDAKICAgIGZpCiAgICBpZiBBcnJheTo6Y29udGFpbnMgIiR7ZnJvbVBhdGh9IiAiJHt1bnRpbEluY2x1c2l2ZVBhdGh9IiAiJEAiICIvIjsgdGhlbgogICAgICByZXR1cm4gMQogICAgZmkKICAgIGZyb21QYXRoPSIkKHJlYWRsaW5rIC1mICIke2Zyb21QYXRofSIvLi4pIgogIGRvbmUKICByZXR1cm4gMQp9CgojIEBkZXNjcmlwdGlvbiByZW1vdmUgY29tbWVudCBsaW5lcyBmcm9tIGlucHV0IG9yIGZpbGVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cwojIEBhcmcgJEAgZmlsZXM6U3RyaW5nW10gKG9wdGlvbmFsKSB0aGUgZmlsZXMgdG8gZmlsdGVyCiMgQGVudiBjb21tZW50TGluZVByZWZpeCBTdHJpbmcgdGhlIGNvbW1lbnQgbGluZSBwcmVmaXggKGRlZmF1bHQgdmFsdWU6ICMpCiMgQGV4aXRjb2RlIDAgaWYgbGluZXMgZmlsdGVyZWQgb3Igbm90CiMgQGV4aXRjb2RlIDIgaWYgZ3JlcCBmYWlscyBmb3IgYW55IG90aGVyIHJlYXNvbnMgdGhhbiBub3QgZm91bmQKIyBAc3RkaW4gdGhlIGZpbGUgYXMgc3RkaW4gdG8gZmlsdGVyIChhbHRlcm5hdGl2ZSB0byBmaWxlcyBhcmd1bWVudCkKIyBAc3Rkb3V0IHRoZSBmaWx0ZXJlZCBsaW5lcwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxMjAKRmlsdGVyczo6Y29tbWVudExpbmVzKCkgewogIGdyZXAgLXZ4RSAiW1s6Ymxhbms6XV0qKCR7Y29tbWVudExpbmVQcmVmaXg6LSN9LiopPyIgIiRAIiB8fCB0ZXN0ICQ/ID0gMQp9CgojIEBkZXNjcmlwdGlvbiBjcmVhdGUgYSB0ZW1wIGZpbGUgdXNpbmcgZGVmYXVsdCBUTVBESVIgdmFyaWFibGUKIyBpbml0aWFsaXplZCBpbiBfaW5jbHVkZXMvX2NvbW1vbkhlYWRlci5zaAojIEBlbnYgVE1QRElSIFN0cmluZyAoZGVmYXVsdCB2YWx1ZSAvdG1wKQojIEBhcmcgJDEgdGVtcGxhdGVOYW1lOlN0cmluZyB0ZW1wbGF0ZSBuYW1lIHRvIHVzZShvcHRpb25hbCkKRnJhbWV3b3JrOjpjcmVhdGVUZW1wRmlsZSgpIHsKICBta3RlbXAgLXAgIiR7VE1QRElSOi0vdG1wfSIgLXQgIiR7MTotfS5YWFhYWFhYWFhYWFgiCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dTa2lwcGVkKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotU0tJUFBFRH0iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhbiBhcnJheQojCiMgQGFyZyAkMSBuZWVkbGU6U3RyaW5nCiMgQGFyZyAkQCBhcnJheTpTdHJpbmdbXQojIEBleGl0Y29kZSAwIGlmIGZvdW5kCiMgQGV4aXRjb2RlIDEgb3RoZXJ3aXNlCiMgQGV4YW1wbGUKIyAgIEFycmF5Ojpjb250YWlucyAiJHtsaWJQYXRofSIgIiR7X19CQVNIX0ZSQU1FV09SS19JTVBPUlRFRF9GSUxFU1tAXX0iCkFycmF5Ojpjb250YWlucygpIHsKICBsb2NhbCBlbGVtZW50CiAgZm9yIGVsZW1lbnQgaW4gIiR7QDoyfSI7IGRvCiAgICBbWyAiJHtlbGVtZW50fSIgPSAiJDEiIF1dICYmIHJldHVybiAwCiAgZG9uZQogIHJldHVybiAxCn0KCiMgRlVOQ1RJT05TCgpmYWNhZGVfbWFpbl9idWlsZFB1c2hEb2NrZXJJbWFnZXNoKCkgewpGUkFNRVdPUktfUk9PVF9ESVI9IiQoY2QgIiR7Q1VSUkVOVF9ESVJ9Ly4uIiAmJiBwd2QgLVApIgpGUkFNRVdPUktfU1JDX0RJUj0iJHtGUkFNRVdPUktfUk9PVF9ESVJ9L3NyYyIKRlJBTUVXT1JLX0JJTl9ESVI9IiR7RlJBTUVXT1JLX1JPT1RfRElSfS9iaW4iCkZSQU1FV09SS19WRU5ET1JfRElSPSIke0ZSQU1FV09SS19ST09UX0RJUn0vdmVuZG9yIgpGUkFNRVdPUktfVkVORE9SX0JJTl9ESVI9IiR7RlJBTUVXT1JLX1JPT1RfRElSfS92ZW5kb3IvYmluIgojIFJFUVVJUkVTCkVudjo6cmVxdWlyZUxvYWQKVUk6OnJlcXVpcmVUaGVtZQpMb2c6OnJlcXVpcmVMb2FkCkNvbXBpbGVyOjpGYWNhZGU6OnJlcXVpcmVDb21tYW5kQmluRGlyCgojIEByZXF1aXJlIENvbXBpbGVyOjpGYWNhZGU6OnJlcXVpcmVDb21tYW5kQmluRGlyCgpkZWNsYXJlIC1hIEJBU0hfRlJBTUVXT1JLX0FSR1ZfRklMVEVSRUQ9KCkKCmNvcHlyaWdodENhbGxiYWNrKCkgewogIGlmIFtbIC16ICIke2NvcHlyaWdodEJlZ2luWWVhcn0iIF1dOyB0aGVuCiAgICBjb3B5cmlnaHRCZWdpblllYXI9IiQoZGF0ZSArJVkpIgogIGZpCiAgZWNobyAiQ29weXJpZ2h0IChjKSAke2NvcHlyaWdodEJlZ2luWWVhcn0tbm93IEZyYW7Dp29pcyBDaGFzdGFuZXQiCn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdEluZm9WZXJib3NlQ2FsbGJhY2soKSB7CiAgQkFTSF9GUkFNRVdPUktfQVJHVl9GSUxURVJFRCs9KC0tdmVyYm9zZSkKfQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZUFyZ0xpc3REZWJ1Z1ZlcmJvc2VDYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdWX0ZJTFRFUkVEKz0oLXZ2KQp9CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdFRyYWNlVmVyYm9zZUNhbGxiYWNrKCkgewogIEJBU0hfRlJBTUVXT1JLX0FSR1ZfRklMVEVSRUQrPSgtdnZ2KQp9CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdEVudkZpbGVDYWxsYmFjaygpIHsgOjsgfQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZUFyZ0xpc3RMb2dMZXZlbENhbGxiYWNrKCkgeyA6OyB9CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdERpc3BsYXlMZXZlbENhbGxiYWNrKCkgeyA6OyB9CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdE5vQ29sb3JDYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdWX0ZJTFRFUkVEKz0oLS1uby1jb2xvcikKfQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZUFyZ0xpc3RUaGVtZUNhbGxiYWNrKCkgeyA6OyB9CiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlQXJnTGlzdFF1aWV0Q2FsbGJhY2soKSB7IDo7IH0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uSGVscENhbGxiYWNrKCkgewogIGJ1aWxkUHVzaERvY2tlckltYWdlQ29tbWFuZCBoZWxwCiAgZXhpdCAwCn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uVmVyc2lvbkNhbGxiYWNrKCkgewogIGVjaG8gIiR7U0NSSVBUX05BTUV9IHZlcnNpb24gMS4wIgogIGV4aXQgMAp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCm9wdGlvbkVudkZpbGVDYWxsYmFjaygpIHsKICBsb2NhbCBlbnZGaWxlPSIkMiIKICBpZiBbWyAhIC1mICIke2VudkZpbGV9IiB8fCAhIC1yICIke2VudkZpbGV9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gLS1lbnYtZmlsZSAtIEZpbGUgJyR7ZW52RmlsZX0nIGRvZXNuJ3QgZXhpc3QiCiAgICBleGl0IDEKICBmaQp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCm9wdGlvbkluZm9WZXJib3NlQ2FsbGJhY2soKSB7CiAgQkFTSF9GUkFNRVdPUktfQVJHU19WRVJCT1NFX09QVElPTj0nLS12ZXJib3NlJwogIEJBU0hfRlJBTUVXT1JLX0FSR1NfVkVSQk9TRT0ke19fVkVSQk9TRV9MRVZFTF9JTkZPfQogIEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUw9JHtfX0xFVkVMX0lORk99Cn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uRGVidWdWZXJib3NlQ2FsbGJhY2soKSB7CiAgQkFTSF9GUkFNRVdPUktfQVJHU19WRVJCT1NFX09QVElPTj0nLXZ2JwogIEJBU0hfRlJBTUVXT1JLX0FSR1NfVkVSQk9TRT0ke19fVkVSQk9TRV9MRVZFTF9ERUJVR30KICBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMPSR7X19MRVZFTF9ERUJVR30KfQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3ICMgaWYgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbgpvcHRpb25UcmFjZVZlcmJvc2VDYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdTX1ZFUkJPU0VfT1BUSU9OPSctdnZ2JwogIEJBU0hfRlJBTUVXT1JLX0FSR1NfVkVSQk9TRT0ke19fVkVSQk9TRV9MRVZFTF9UUkFDRX0KICBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMPSR7X19MRVZFTF9ERUJVR30KfQoKZ2V0TGV2ZWwoKSB7CiAgbG9jYWwgbGV2ZWxOYW1lPSIkMSIKICBjYXNlICIke2xldmVsTmFtZV5efSIgaW4KICAgIE9GRikKICAgICAgZWNobyAiJHtfX0xFVkVMX09GRn0iCiAgICAgIDs7CiAgICBFUlJPUikKICAgICAgZWNobyAiJHtfX0xFVkVMX0VSUk9SfSIKICAgICAgOzsKICAgIFdBUk5JTkcpCiAgICAgIGVjaG8gIiR7X19MRVZFTF9XQVJOSU5HfSIKICAgICAgOzsKICAgIElORk8pCiAgICAgIGVjaG8gIiR7X19MRVZFTF9JTkZPfSIKICAgICAgOzsKICAgIERFQlVHIHwgVFJBQ0UpCiAgICAgIGVjaG8gIiR7X19MRVZFTF9ERUJVR30iCiAgICAgIDs7CiAgICAqKQogICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIEludmFsaWQgbGV2ZWwgJHtsZXZlbH0iCiAgICAgIHJldHVybiAxCiAgZXNhYwp9CgpnZXRWZXJib3NlTGV2ZWwoKSB7CiAgbG9jYWwgbGV2ZWxOYW1lPSIkMSIKICBjYXNlICIke2xldmVsTmFtZV5efSIgaW4KICAgIE9GRikKICAgICAgZWNobyAiJHtfX1ZFUkJPU0VfTEVWRUxfT0ZGfSIKICAgICAgOzsKICAgIEVSUk9SIHwgV0FSTklORyB8IElORk8pCiAgICAgIGVjaG8gIiR7X19WRVJCT1NFX0xFVkVMX0lORk99IgogICAgICA7OwogICAgREVCVUcpCiAgICAgIGVjaG8gIiR7X19WRVJCT1NFX0xFVkVMX0RFQlVHfSIKICAgICAgOzsKICAgIFRSQUNFKQogICAgICBlY2hvICIke19fVkVSQk9TRV9MRVZFTF9UUkFDRX0iCiAgICAgIDs7CiAgICAqKQogICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIEludmFsaWQgbGV2ZWwgJHtsZXZlbH0iCiAgICAgIHJldHVybiAxCiAgZXNhYwp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCm9wdGlvbkRpc3BsYXlMZXZlbENhbGxiYWNrKCkgewogIGxvY2FsIGxldmVsPSIkMiIKICBsb2NhbCBsb2dMZXZlbCB2ZXJib3NlTGV2ZWwKICBsb2dMZXZlbD0iJChnZXRMZXZlbCAiJHtsZXZlbH0iKSIKICB2ZXJib3NlTGV2ZWw9IiQoZ2V0VmVyYm9zZUxldmVsICIke2xldmVsfSIpIgogIEJBU0hfRlJBTUVXT1JLX0FSR1NfVkVSQk9TRT0ke3ZlcmJvc2VMZXZlbH0KICBCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMPSR7bG9nTGV2ZWx9Cn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uTG9nTGV2ZWxDYWxsYmFjaygpIHsKICBsb2NhbCBsZXZlbD0iJDIiCiAgbG9jYWwgbG9nTGV2ZWwgdmVyYm9zZUxldmVsCiAgbG9nTGV2ZWw9IiQoZ2V0TGV2ZWwgIiR7bGV2ZWx9IikiCiAgdmVyYm9zZUxldmVsPSIkKGdldFZlcmJvc2VMZXZlbCAiJHtsZXZlbH0iKSIKICBCQVNIX0ZSQU1FV09SS19BUkdTX1ZFUkJPU0U9JHt2ZXJib3NlTGV2ZWx9CiAgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMPSR7bG9nTGV2ZWx9Cn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uTG9nRmlsZUNhbGxiYWNrKCkgewogIGxvY2FsIGxvZ0ZpbGU9IiQyIgogIEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFPSIke2xvZ0ZpbGV9Igp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCm9wdGlvblF1aWV0Q2FsbGJhY2soKSB7CiAgQkFTSF9GUkFNRVdPUktfUVVJRVRfTU9ERT0xCn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4Kb3B0aW9uTm9Db2xvckNhbGxiYWNrKCkgewogIFVJOjp0aGVtZSAibm9Db2xvciIKfQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3ICMgaWYgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbgpvcHRpb25UaGVtZUNhbGxiYWNrKCkgewogIFVJOjp0aGVtZSAiJDIiCn0KCmRpc3BsYXlDb25maWcoKSB7CiAgZWNobyAiQ29uZmlnIgogIFVJOjpkcmF3TGluZSAiLSIKICBsb2NhbCB2YXIKICB3aGlsZSByZWFkIC1yIHZhcjsgZG8KICAgIHByaW50ZiAnJS00MHMgPSAlc1xuJyAiJHt2YXJ9IiAiJChkZWNsYXJlIC1wICIke3Zhcn0iIHwgc2VkIC1FIC1lICdzL15bXj1dKz0oLiopL1wxLycpIgogIGRvbmUgPCA8KHR5cGVzZXQgLXAgfCBhd2sgJ21hdGNoKCQzLCAiXihCQVNIX0ZSQU1FV09SS19bXj1dKyk9IiwgbSkgeyBwcmludCBtWzFdIH0nIHwgc29ydCkKICBleGl0IDAKfQoKb3B0aW9uQmFzaEZyYW1ld29ya0NvbmZpZ0NhbGxiYWNrKCkgewogIGlmIFtbICEgLWYgIiQyIiBdXTsgdGhlbgogICAgTG9nOjpmYXRhbCAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIEJhc2ggZnJhbWV3b3JrIGNvbmZpZyBmaWxlICckMicgZG9lcyBub3QgZXhpc3RzIgogIGZpCn0KCmRlZmF1bHRGcmFtZXdvcmtDb25maWc9IiQoCiAgY2F0IDw8J0VPRicKIyBjb3BpZWQgZnJvbSBzcmMvX2luY2x1ZGVzLy5mcmFtZXdvcmstY29uZmlnLmRlZmF1bHQKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CgojIGRlc2NyaWJlIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIHNraXBwZWQgZnJvbSBiZWluZyBpbXBvcnRlZApGUkFNRVdPUktfRlVOQ1RJT05TX0lHTk9SRV9SRUdFWFA9J14oTmFtZXNwYWNlOjpmdW5jdGlvbnN8RnVuY3Rpb25zOjpteUZ1bmN0aW9ufE5hbWVzcGFjZTo6cmVxdWlyZVNvbWV0aGluZ3xBY3F1aXJlOjpGb3JjZUlQdjQpJCcKIyBkZXNjcmliZSB0aGUgZmlsZXMgdGhhdCBkbyBub3QgY29udGFpbiBmdW5jdGlvbiB0byBiZSBpbXBvcnRlZApOT05fRlJBTUVXT1JLX0ZJTEVTX1JFR0VYUD0iKF5iaW4vfC5mcmFtZXdvcmstY29uZmlnfC5iYXRzJHwvdGVzdHNEYXRhL3xebWFudWFsVGVzdHMvfC9fLnNoJHwvWlpaLnNoJHwvX19hbGwuc2gkfF5zcmMvX2JpbmFyaWVzfF5zcmMvX2luY2x1ZGVzfF5zcmMvYmF0c0hlYWRlcnMuc2gkfF5zcmMvX3N0YW5kYWxvbmUpIgojIGRlc2NyaWJlIHRoZSBmaWxlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgYmF0cyBmaWxlCkJBVFNfRklMRV9OT1RfTkVFREVEX1JFR0VYUD0iKF5iaW4vfC5mcmFtZXdvcmstY29uZmlnfC5iYXRzJHwvdGVzdHNEYXRhL3xebWFudWFsVGVzdHMvfC9fLnNoJHwvWlpaLnNoJHwvX19hbGwuc2gkfF5zcmMvYmF0c0hlYWRlcnMuc2gkfF5zcmMvX2luY2x1ZGVzKSIKIyBkZXNjcmliZSB0aGUgZmlsZXMgdGhhdCBhcmUgYWxsb3dlZCB0byBub3QgaGF2ZSBhIGZ1bmN0aW9uIG1hdGNoaW5nIHRoZSBmaWxlbmFtZQpGUkFNRVdPUktfRklMRVNfRlVOQ1RJT05fTUFUQ0hJTkdfSUdOT1JFX1JFR0VYUD0iXmJpbi98XlwuZnJhbWV3b3JrLWNvbmZpZyR8XmJ1aWxkLnNoJHxcLnRwbCR8L3Rlc3RzRGF0YS98Xm1hbnVhbFRlc3RzL3xcLmJhdHMkIgojIFNvdXJjZSBkaXJlY3RvcmllcwpGUkFNRVdPUktfU1JDX0RJUlM9KAogICIke0ZSQU1FV09SS19ST09UX0RJUn0vc3JjIgopCgojIGV4cG9ydCBoZXJlIGFsbCB0aGUgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHlvdXIgdGVtcGxhdGVzCmV4cG9ydCBSRVBPU0lUT1JZX1VSTD0iaHR0cHM6Ly9naXRodWIuY29tL2ZjaGFzdGFuZXQvYmFzaC10b29scy1mcmFtZXdvcmsiCkVPRgopIgoKY29tbWFuZE9wdGlvblBhcnNlRmluaXNoZWQoKSB7CiAgaWYgW1sgLXogIiR7QkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTWzBdKzF9IiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTPSgpCiAgZmkKICBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMrPSgiJHtvcHRpb25FbnZGaWxlc1tAXX0iKQogIGV4cG9ydCBCQVNIX0ZSQU1FV09SS19FTlZfRklMRVMKICBFbnY6OnJlcXVpcmVMb2FkCiAgTG9nOjpyZXF1aXJlTG9hZAoKICAjIGxvYWQgLmZyYW1ld29yay1jb25maWcKICBpZiBbWyAtbiAiJHtvcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnfSIgJiYgLWYgIiR7b3B0aW9uQmFzaEZyYW1ld29ya0NvbmZpZ30iIF1dOyB0aGVuCiAgICBCQVNIX0ZSQU1FV09SS19DT05GSUdfRklMRT0iJHtvcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnfSIKICAgICMgc2hlbGxjaGVjayBzb3VyY2U9Ly5mcmFtZXdvcmstY29uZmlnCiAgICBzb3VyY2UgIiR7b3B0aW9uQmFzaEZyYW1ld29ya0NvbmZpZ30iIHx8CiAgICAgIExvZzo6ZmF0YWwgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBlcnJvciB3aGlsZSBsb2FkaW5nIHNwZWNpZmljIC5mcmFtZXdvcmstY29uZmlnIGZpbGU6ICR7b3B0aW9uQmFzaEZyYW1ld29ya0NvbmZpZ30iCiAgZWxzZQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICBCQVNIX0ZSQU1FV09SS19DT05GSUdfRklMRT0iIgogICAgIyBzaGVsbGNoZWNrIHNvdXJjZT0vLmZyYW1ld29yay1jb25maWcKICAgIEZyYW1ld29yazo6bG9hZENvbmZpZyBCQVNIX0ZSQU1FV09SS19DT05GSUdfRklMRSAiJHtGUkFNRVdPUktfUk9PVF9ESVJ9IiB8fCB7CiAgICAgICMgbG9hZCBkZWZhdWx0IHRlbXBsYXRlIGZyYW1ld29yayBjb25maWcKICAgICAgaWYgW1sgISAtZiAiJHtQRVJTSVNURU5UX1RNUERJUn0vLmZyYW1ld29yay1jb25maWciIF1dOyB0aGVuCiAgICAgICAgZWNobyAiJHtkZWZhdWx0RnJhbWV3b3JrQ29uZmlnfSIgPiAiJHtQRVJTSVNURU5UX1RNUERJUn0vLmZyYW1ld29yay1jb25maWciCiAgICAgIGZpCiAgICAgIEZyYW1ld29yazo6bG9hZENvbmZpZyBCQVNIX0ZSQU1FV09SS19DT05GSUdfRklMRSAiJHtQRVJTSVNURU5UX1RNUERJUn0iIHx8IHsKICAgICAgICBMb2c6OmZhdGFsICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gZXJyb3Igd2hpbGUgbG9hZGluZyAuZnJhbWV3b3JrLWNvbmZpZy5kZWZhdWx0IGZpbGUiCiAgICAgIH0KICAgICAgTG9nOjpkaXNwbGF5V2FybmluZyAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIExvYWQgZGVmYXVsdCAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIC0gJHtQRVJTSVNURU5UX1RNUERJUn0vLmZyYW1ld29yay1jb25maWciCiAgICB9CiAgZmkKCiAgaWYgW1sgIiR7b3B0aW9uQ29uZmlnfSIgPSAiMSIgXV07IHRoZW4KICAgIGRpc3BsYXlDb25maWcKICBmaQp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZU9wdGlvblZlbmRvckNhbGxiYWNrKCkgewogIEJBU0hfRlJBTUVXT1JLX0FSR1ZfRklMVEVSRUQrPSgiJDEiICIkMiIpCn0KCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNyAjIGlmIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4KdXBkYXRlT3B0aW9uQmFzaFZlcnNpb25DYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdWX0ZJTFRFUkVEKz0oIiQxIiAiJDIiKQp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZU9wdGlvbkJhc2hCYXNlSW1hZ2VDYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdWX0ZJTFRFUkVEKz0oIiQxIiAiJDIiKQp9CgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcgIyBpZiBmdW5jdGlvbiBpcyBvdmVycmlkZGVuCnVwZGF0ZU9wdGlvbkJyYW5jaE5hbWVDYWxsYmFjaygpIHsKICBCQVNIX0ZSQU1FV09SS19BUkdWX0ZJTFRFUkVEKz0oIiQxIiAiJDIiKQp9CgpkZWNsYXJlIG9wdGlvblZlbmRvcj0idWJ1bnR1IgpkZWNsYXJlIG9wdGlvbkJhc2hWZXJzaW9uPSI1LjEiCmRlY2xhcmUgb3B0aW9uQmFzaEJhc2VJbWFnZT0idWJ1bnR1OjIwLjA0IgoKYnVpbGRQdXNoRG9ja2VySW1hZ2VDb21tYW5kKCkgewogIGxvY2FsIG9wdGlvbnNfcGFyc2VfY21kPSIkMSIKICBzaGlmdCB8fCB0cnVlCgogIGlmIFtbICIke29wdGlvbnNfcGFyc2VfY21kfSIgPSAicGFyc2UiIF1dOyB0aGVuCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVmVuZG9yCiAgICAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25WZW5kb3IgPSAwKSkgfHwgdHJ1ZQogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hWZXJzaW9uCiAgICAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25CYXNoVmVyc2lvbiA9IDApKSB8fCB0cnVlCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQmFzaEJhc2VJbWFnZQogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQmFzaEJhc2VJbWFnZSA9IDApKSB8fCB0cnVlCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQnJhbmNoTmFtZQogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQnJhbmNoTmFtZSA9IDApKSB8fCB0cnVlCiAgICBvcHRpb25QdXNoPSIwIgogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblB1c2gKICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblB1c2ggPSAwKSkgfHwgdHJ1ZQogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hGcmFtZXdvcmtDb25maWcKICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hGcmFtZXdvcmtDb25maWcgPSAwKSkgfHwgdHJ1ZQogICAgb3B0aW9uQ29uZmlnPSIwIgogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkNvbmZpZwogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQ29uZmlnID0gMCkpIHx8IHRydWUKICAgIG9wdGlvbkluZm9WZXJib3NlPSIwIgogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkluZm9WZXJib3NlCiAgICAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25JbmZvVmVyYm9zZSA9IDApKSB8fCB0cnVlCiAgICBvcHRpb25EZWJ1Z1ZlcmJvc2U9IjAiCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uRGVidWdWZXJib3NlCiAgICAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25EZWJ1Z1ZlcmJvc2UgPSAwKSkgfHwgdHJ1ZQogICAgb3B0aW9uVHJhY2VWZXJib3NlPSIwIgogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblRyYWNlVmVyYm9zZQogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVHJhY2VWZXJib3NlID0gMCkpIHx8IHRydWUKICAgIG9wdGlvbk5vQ29sb3I9IjAiCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTm9Db2xvcgogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTm9Db2xvciA9IDApKSB8fCB0cnVlCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVGhlbWUKICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblRoZW1lID0gMCkpIHx8IHRydWUKICAgIG9wdGlvbkhlbHA9IjAiCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uSGVscAogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uSGVscCA9IDApKSB8fCB0cnVlCiAgICBvcHRpb25WZXJzaW9uPSIwIgogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblZlcnNpb24KICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblZlcnNpb24gPSAwKSkgfHwgdHJ1ZQogICAgb3B0aW9uUXVpZXQ9IjAiCiAgICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uUXVpZXQKICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblF1aWV0ID0gMCkpIHx8IHRydWUKICAgIGxvY2FsIC1pIG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25Mb2dMZXZlbAogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTG9nTGV2ZWwgPSAwKSkgfHwgdHJ1ZQogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkxvZ0ZpbGUKICAgICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkxvZ0ZpbGUgPSAwKSkgfHwgdHJ1ZQogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkRpc3BsYXlMZXZlbAogICAgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uRGlzcGxheUxldmVsID0gMCkpIHx8IHRydWUKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9wYXJzZWRBcmdJbmRleD0wCiAgICB3aGlsZSAoKCQjID4gMCkpOyBkbwogICAgICBsb2NhbCBvcHRpb25zX3BhcnNlX2FyZz0iJDEiCiAgICAgIGxvY2FsIGFyZ09wdERlZmF1bHRCZWhhdmlvcj0wCiAgICAgIGNhc2UgIiR7b3B0aW9uc19wYXJzZV9hcmd9IiBpbgogICAgICAgICMgT3B0aW9uIDEvMTkKICAgICAgICAjIE9wdGlvbiBvcHRpb25WZW5kb3IgLS12ZW5kb3IgdmFyaWFibGVUeXBlIFN0cmluZyBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICdhbHBpbmV8dWJ1bnR1JyByZWdleHAgJycKICAgICAgICAtLXZlbmRvcikKICAgICAgICAgIHNoaWZ0CiAgICAgICAgICBpZiAoKCQjID09IDApKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIGEgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIGlmIFtbICEgIiQxIiA9fiBhbHBpbmV8dWJ1bnR1IF1dOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gdmFsdWUgJyQxJyBpcyBub3QgcGFydCBvZiBhdXRob3JpemVkIHZhbHVlcyhhbHBpbmV8dWJ1bnR1KSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICBpZiAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25WZW5kb3IgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25WZW5kb3IpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25WZW5kb3I9IiQxIgogICAgICAgICAgdXBkYXRlT3B0aW9uVmVuZG9yQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IiAiJHtvcHRpb25WZW5kb3J9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiAyLzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uQmFzaFZlcnNpb24gLS1iYXNoLXZlcnNpb24gdmFyaWFibGVUeXBlIFN0cmluZyBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICc0LjR8NS4wfDUuMXw1LjInIHJlZ2V4cCAnJwogICAgICAgIC0tYmFzaC12ZXJzaW9uKQogICAgICAgICAgc2hpZnQKICAgICAgICAgIGlmICgoJCMgPT0gMCkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gYSB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgW1sgISAiJDEiID1+IDQuNHw1LjB8NS4xfDUuMiBdXTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIHZhbHVlICckMScgaXMgbm90IHBhcnQgb2YgYXV0aG9yaXplZCB2YWx1ZXMoNC40fDUuMHw1LjF8NS4yKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICBpZiAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25CYXNoVmVyc2lvbiA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hWZXJzaW9uKSkKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgb3B0aW9uQmFzaFZlcnNpb249IiQxIgogICAgICAgICAgdXBkYXRlT3B0aW9uQmFzaFZlcnNpb25DYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkJhc2hWZXJzaW9ufSIKICAgICAgICAgIDs7CiAgICAgICAgIyBPcHRpb24gMy8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvbkJhc2hCYXNlSW1hZ2UgLS1iYXNoLWJhc2UtaW1hZ2UgdmFyaWFibGVUeXBlIFN0cmluZyBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICcnIHJlZ2V4cCAnJwogICAgICAgIC0tYmFzaC1iYXNlLWltYWdlKQogICAgICAgICAgc2hpZnQKICAgICAgICAgIGlmICgoJCMgPT0gMCkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gYSB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQmFzaEJhc2VJbWFnZSA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hCYXNlSW1hZ2UpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25CYXNoQmFzZUltYWdlPSIkMSIKICAgICAgICAgIHVwZGF0ZU9wdGlvbkJhc2hCYXNlSW1hZ2VDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkJhc2hCYXNlSW1hZ2V9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiA0LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uQnJhbmNoTmFtZSAtLWJyYW5jaC1uYW1lIHZhcmlhYmxlVHlwZSBTdHJpbmcgbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLWJyYW5jaC1uYW1lKQogICAgICAgICAgc2hpZnQKICAgICAgICAgIGlmICgoJCMgPT0gMCkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gYSB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uQnJhbmNoTmFtZSA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJyYW5jaE5hbWUpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25CcmFuY2hOYW1lPSIkMSIKICAgICAgICAgIHVwZGF0ZU9wdGlvbkJyYW5jaE5hbWVDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkJyYW5jaE5hbWV9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiA1LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uUHVzaCAtLXB1c2ggdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLXB1c2gpCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIG9wdGlvblB1c2g9IjEiCiAgICAgICAgICBpZiAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25QdXNoID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uUHVzaCkpCiAgICAgICAgICA7OwogICAgICAgICMgT3B0aW9uIDYvMTkKICAgICAgICAjIE9wdGlvbiBvcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnIC0tYmFzaC1mcmFtZXdvcmstY29uZmlnIHZhcmlhYmxlVHlwZSBTdHJpbmcgbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLWJhc2gtZnJhbWV3b3JrLWNvbmZpZykKICAgICAgICAgIHNoaWZ0CiAgICAgICAgICBpZiAoKCQjID09IDApKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIGEgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkJhc2hGcmFtZXdvcmtDb25maWcgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnKSkKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgb3B0aW9uQmFzaEZyYW1ld29ya0NvbmZpZz0iJDEiCiAgICAgICAgICBvcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IiAiJHtvcHRpb25CYXNoRnJhbWV3b3JrQ29uZmlnfSIKICAgICAgICAgIDs7CiAgICAgICAgIyBPcHRpb24gNy8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvbkNvbmZpZyAtLWNvbmZpZyB2YXJpYWJsZVR5cGUgQm9vbGVhbiBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICcnIHJlZ2V4cCAnJwogICAgICAgIC0tY29uZmlnKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25Db25maWc9IjEiCiAgICAgICAgICBpZiAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25Db25maWcgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25Db25maWcpKQogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiA4LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uSW5mb1ZlcmJvc2UgLS12ZXJib3NlfC12IHZhcmlhYmxlVHlwZSBCb29sZWFuIG1pbiAwIG1heCAxIGF1dGhvcml6ZWRWYWx1ZXMgJycgcmVnZXhwICcnCiAgICAgICAgLS12ZXJib3NlIHwgLXYpCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIG9wdGlvbkluZm9WZXJib3NlPSIxIgogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uSW5mb1ZlcmJvc2UgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25JbmZvVmVyYm9zZSkpCiAgICAgICAgICBvcHRpb25JbmZvVmVyYm9zZUNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIHVwZGF0ZUFyZ0xpc3RJbmZvVmVyYm9zZUNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIDs7CiAgICAgICAgIyBPcHRpb24gOS8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvbkRlYnVnVmVyYm9zZSAtdnYgdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtdnYpCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIG9wdGlvbkRlYnVnVmVyYm9zZT0iMSIKICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkRlYnVnVmVyYm9zZSA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkRlYnVnVmVyYm9zZSkpCiAgICAgICAgICBvcHRpb25EZWJ1Z1ZlcmJvc2VDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iCiAgICAgICAgICB1cGRhdGVBcmdMaXN0RGVidWdWZXJib3NlQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiAxMC8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvblRyYWNlVmVyYm9zZSAtdnZ2IHZhcmlhYmxlVHlwZSBCb29sZWFuIG1pbiAwIG1heCAxIGF1dGhvcml6ZWRWYWx1ZXMgJycgcmVnZXhwICcnCiAgICAgICAgLXZ2dikKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgb3B0aW9uVHJhY2VWZXJib3NlPSIxIgogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVHJhY2VWZXJib3NlID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVHJhY2VWZXJib3NlKSkKICAgICAgICAgIG9wdGlvblRyYWNlVmVyYm9zZUNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIHVwZGF0ZUFyZ0xpc3RUcmFjZVZlcmJvc2VDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iCiAgICAgICAgICA7OwogICAgICAgICMgT3B0aW9uIDExLzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uRW52RmlsZXMgLS1lbnYtZmlsZSB2YXJpYWJsZVR5cGUgU3RyaW5nQXJyYXkgbWluIDAgbWF4IC0xIGF1dGhvcml6ZWRWYWx1ZXMgJycgcmVnZXhwICcnCiAgICAgICAgLS1lbnYtZmlsZSkKICAgICAgICAgIHNoaWZ0CiAgICAgICAgICBpZiAoKCQjID09IDApKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIGEgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uRW52RmlsZXMpKQogICAgICAgICAgb3B0aW9uRW52RmlsZXMrPSgiJDEiKQogICAgICAgICAgb3B0aW9uRW52RmlsZUNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIgIiR7b3B0aW9uRW52RmlsZXNbQF19IgogICAgICAgICAgdXBkYXRlQXJnTGlzdEVudkZpbGVDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkVudkZpbGVzW0BdfSIKICAgICAgICAgIDs7CiAgICAgICAgIyBPcHRpb24gMTIvMTkKICAgICAgICAjIE9wdGlvbiBvcHRpb25Ob0NvbG9yIC0tbm8tY29sb3IgdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLW5vLWNvbG9yKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25Ob0NvbG9yPSIxIgogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTm9Db2xvciA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbk5vQ29sb3IpKQogICAgICAgICAgb3B0aW9uTm9Db2xvckNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIHVwZGF0ZUFyZ0xpc3ROb0NvbG9yQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiAxMy8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvblRoZW1lIC0tdGhlbWUgdmFyaWFibGVUeXBlIFN0cmluZyBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICdkZWZhdWx0fGRlZmF1bHQtZm9yY2V8bm9Db2xvcicgcmVnZXhwICcnCiAgICAgICAgLS10aGVtZSkKICAgICAgICAgIHNoaWZ0CiAgICAgICAgICBpZiAoKCQjID09IDApKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIGEgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIGlmIFtbICEgIiQxIiA9fiBkZWZhdWx0fGRlZmF1bHQtZm9yY2V8bm9Db2xvciBdXTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIHZhbHVlICckMScgaXMgbm90IHBhcnQgb2YgYXV0aG9yaXplZCB2YWx1ZXMoZGVmYXVsdHxkZWZhdWx0LWZvcmNlfG5vQ29sb3IpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblRoZW1lID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVGhlbWUpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25UaGVtZT0iJDEiCiAgICAgICAgICBvcHRpb25UaGVtZUNhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIgIiR7b3B0aW9uVGhlbWV9IgogICAgICAgICAgdXBkYXRlQXJnTGlzdFRoZW1lQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IiAiJHtvcHRpb25UaGVtZX0iCiAgICAgICAgICA7OwogICAgICAgICMgT3B0aW9uIDE0LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uSGVscCAtLWhlbHB8LWggdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLWhlbHAgfCAtaCkKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgb3B0aW9uSGVscD0iMSIKICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkhlbHAgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25IZWxwKSkKICAgICAgICAgIG9wdGlvbkhlbHBDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iCiAgICAgICAgICA7OwogICAgICAgICMgT3B0aW9uIDE1LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uVmVyc2lvbiAtLXZlcnNpb24gdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLXZlcnNpb24pCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIG9wdGlvblZlcnNpb249IjEiCiAgICAgICAgICBpZiAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25WZXJzaW9uID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uVmVyc2lvbikpCiAgICAgICAgICBvcHRpb25WZXJzaW9uQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiAxNi8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvblF1aWV0IC0tcXVpZXR8LXEgdmFyaWFibGVUeXBlIEJvb2xlYW4gbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLXF1aWV0IHwgLXEpCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIG9wdGlvblF1aWV0PSIxIgogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uUXVpZXQgPj0gMSkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gTWF4aW11bSBudW1iZXIgb2Ygb3B0aW9uIG9jY3VycmVuY2VzIHJlYWNoZWQoMSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25RdWlldCkpCiAgICAgICAgICBvcHRpb25RdWlldENhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIHVwZGF0ZUFyZ0xpc3RRdWlldENhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgIDs7CiAgICAgICAgIyBPcHRpb24gMTcvMTkKICAgICAgICAjIE9wdGlvbiBvcHRpb25Mb2dMZXZlbCAtLWxvZy1sZXZlbCB2YXJpYWJsZVR5cGUgU3RyaW5nIG1pbiAwIG1heCAxIGF1dGhvcml6ZWRWYWx1ZXMgJ09GRnxFUlJPUnxXQVJOSU5HfElORk98REVCVUd8VFJBQ0UnIHJlZ2V4cCAnJwogICAgICAgIC0tbG9nLWxldmVsKQogICAgICAgICAgc2hpZnQKICAgICAgICAgIGlmICgoJCMgPT0gMCkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gYSB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgW1sgISAiJDEiID1+IE9GRnxFUlJPUnxXQVJOSU5HfElORk98REVCVUd8VFJBQ0UgXV07IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSB2YWx1ZSAnJDEnIGlzIG5vdCBwYXJ0IG9mIGF1dGhvcml6ZWQgdmFsdWVzKE9GRnxFUlJPUnxXQVJOSU5HfElORk98REVCVUd8VFJBQ0UpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkxvZ0xldmVsID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTG9nTGV2ZWwpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25Mb2dMZXZlbD0iJDEiCiAgICAgICAgICBvcHRpb25Mb2dMZXZlbENhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIgIiR7b3B0aW9uTG9nTGV2ZWx9IgogICAgICAgICAgdXBkYXRlQXJnTGlzdExvZ0xldmVsQ2FsbGJhY2sgIiR7b3B0aW9uc19wYXJzZV9hcmd9IiAiJHtvcHRpb25Mb2dMZXZlbH0iCiAgICAgICAgICA7OwogICAgICAgICMgT3B0aW9uIDE4LzE5CiAgICAgICAgIyBPcHRpb24gb3B0aW9uTG9nRmlsZSAtLWxvZy1maWxlIHZhcmlhYmxlVHlwZSBTdHJpbmcgbWluIDAgbWF4IDEgYXV0aG9yaXplZFZhbHVlcyAnJyByZWdleHAgJycKICAgICAgICAtLWxvZy1maWxlKQogICAgICAgICAgc2hpZnQKICAgICAgICAgIGlmICgoJCMgPT0gMCkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gT3B0aW9uICR7b3B0aW9uc19wYXJzZV9hcmd9IC0gYSB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uTG9nRmlsZSA+PSAxKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkxvZ0ZpbGUpKQogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBvcHRpb25Mb2dGaWxlPSIkMSIKICAgICAgICAgIG9wdGlvbkxvZ0ZpbGVDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkxvZ0ZpbGV9IgogICAgICAgICAgdXBkYXRlQXJnTGlzdExvZ0ZpbGVDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkxvZ0ZpbGV9IgogICAgICAgICAgOzsKICAgICAgICAjIE9wdGlvbiAxOS8xOQogICAgICAgICMgT3B0aW9uIG9wdGlvbkRpc3BsYXlMZXZlbCAtLWRpc3BsYXktbGV2ZWwgdmFyaWFibGVUeXBlIFN0cmluZyBtaW4gMCBtYXggMSBhdXRob3JpemVkVmFsdWVzICdPRkZ8RVJST1J8V0FSTklOR3xJTkZPfERFQlVHfFRSQUNFJyByZWdleHAgJycKICAgICAgICAtLWRpc3BsYXktbGV2ZWwpCiAgICAgICAgICBzaGlmdAogICAgICAgICAgaWYgKCgkIyA9PSAwKSk7IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBhIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZCIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICBpZiBbWyAhICIkMSIgPX4gT0ZGfEVSUk9SfFdBUk5JTkd8SU5GT3xERUJVR3xUUkFDRSBdXTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIHZhbHVlICckMScgaXMgbm90IHBhcnQgb2YgYXV0aG9yaXplZCB2YWx1ZXMoT0ZGfEVSUk9SfFdBUk5JTkd8SU5GT3xERUJVR3xUUkFDRSkiCiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgICBmaQogICAgICAgICAgaWYgKChvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uRGlzcGxheUxldmVsID49IDEpKTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSAtIE1heGltdW0gbnVtYmVyIG9mIG9wdGlvbiBvY2N1cnJlbmNlcyByZWFjaGVkKDEpIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uRGlzcGxheUxldmVsKSkKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgb3B0aW9uRGlzcGxheUxldmVsPSIkMSIKICAgICAgICAgIG9wdGlvbkRpc3BsYXlMZXZlbENhbGxiYWNrICIke29wdGlvbnNfcGFyc2VfYXJnfSIgIiR7b3B0aW9uRGlzcGxheUxldmVsfSIKICAgICAgICAgIHVwZGF0ZUFyZ0xpc3REaXNwbGF5TGV2ZWxDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkRpc3BsYXlMZXZlbH0iCiAgICAgICAgICA7OwogICAgICAgIC0qKQogICAgICAgICAgaWYgW1sgIiR7YXJnT3B0RGVmYXVsdEJlaGF2aW9yfSIgPSAiMCIgXV07IHRoZW4KICAgICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBJbnZhbGlkIG9wdGlvbiAke29wdGlvbnNfcGFyc2VfYXJnfSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICA7OwogICAgICAgICopCiAgICAgICAgICBpZiBbWyAiJHthcmdPcHREZWZhdWx0QmVoYXZpb3J9IiA9ICIwIiBdXTsgdGhlbgogICAgICAgICAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIEFyZ3VtZW50IC0gdG9vIG11Y2ggYXJndW1lbnRzIHByb3ZpZGVkIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKICAgICAgICAgIDs7CiAgICAgIGVzYWMKICAgICAgc2hpZnQgfHwgdHJ1ZQogICAgZG9uZQogICAgY29tbWFuZE9wdGlvblBhcnNlRmluaXNoZWQKICAgIExvZzo6ZGlzcGxheURlYnVnICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gcGFyc2UgYXJndW1lbnRzOiAke0JBU0hfRlJBTUVXT1JLX0FSR1ZbKl19IgogICAgTG9nOjpkaXNwbGF5RGVidWcgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBwYXJzZSBmaWx0ZXJlZCBhcmd1bWVudHM6ICR7QkFTSF9GUkFNRVdPUktfQVJHVl9GSUxURVJFRFsqXX0iCiAgZWxpZiBbWyAiJHtvcHRpb25zX3BhcnNlX2NtZH0iID0gImhlbHAiIF1dOyB0aGVuCiAgICBlY2hvIC1lICIkKEFycmF5Ojp3cmFwICIgIiA4MCAwICIke19fSEVMUF9USVRMRV9DT0xPUn1ERVNDUklQVElPTjoke19fUkVTRVRfQ09MT1J9IiAicHVsbCwgYnVpbGQgYW5kIHB1c2ggZG9ja2VyIGltYWdlCgotIHB1bGwgcHJldmlvdXMgZG9ja2VyIGltYWdlIGZyb20gZG9ja2VyIGh1YiBpZgogIGV4aXN0cwotIGJ1aWxkIG5ldyBpbWFnZSB1c2luZyBwcmV2aW91cyBpbWFnZSBhcyBjYWNoZQotIHRhZyBidWlsdCBpbWFnZQotIHB1c2ggaXQgdG8gZG9ja2VyIHJlZ2lzdHJ5CgphZGRpdGlvbmFsIGRvY2tlciBidWlsZCBvcHRpb25zIGNhbiBiZSBwYXNzZWQKICB2aWEgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfURPQ0tFUl9CVUlMRF9PUFRJT05TJHtfX0hFTFBfTk9STUFMfSBlbnYgdmFyaWFibGUKCklOVEVSTkFMCiIpIgogICAgZWNobwoKICAgIGVjaG8gLWUgIiQoQXJyYXk6OndyYXAgIiAiIDgwIDIgIiR7X19IRUxQX1RJVExFX0NPTE9SfVVTQUdFOiR7X19SRVNFVF9DT0xPUn0iICIke1NDUklQVF9OQU1FfSIgIltPUFRJT05TXSIpIgogICAgZWNobyAtZSAiJChBcnJheTo6d3JhcCAiICIgODAgMiAiJHtfX0hFTFBfVElUTEVfQ09MT1J9VVNBR0U6JHtfX1JFU0VUX0NPTE9SfSIgXAogICAgICAiJHtTQ1JJUFRfTkFNRX0iIFwKICAgICAgIlstLXZlbmRvciA8U3RyaW5nPl0iICJbLS1iYXNoLXZlcnNpb24gPFN0cmluZz5dIiAiWy0tYmFzaC1iYXNlLWltYWdlIDxTdHJpbmc+XSIgIlstLWJyYW5jaC1uYW1lIDxTdHJpbmc+XSIgIlstLXB1c2hdIiAiWy0tYmFzaC1mcmFtZXdvcmstY29uZmlnIDxTdHJpbmc+XSIgIlstLWNvbmZpZ10iICJbLS12ZXJib3NlfC12XSIgIlstdnZdIiAiWy12dnZdIiAiWy0tZW52LWZpbGUgPFN0cmluZz5dIiAiWy0tbm8tY29sb3JdIiAiWy0tdGhlbWUgPFN0cmluZz5dIiAiWy0taGVscHwtaF0iICJbLS12ZXJzaW9uXSIgIlstLXF1aWV0fC1xXSIgIlstLWxvZy1sZXZlbCA8U3RyaW5nPl0iICJbLS1sb2ctZmlsZSA8U3RyaW5nPl0iICJbLS1kaXNwbGF5LWxldmVsIDxTdHJpbmc+XSIpIgogICAgZWNobwogICAgZWNobyAtZSAiJHtfX0hFTFBfVElUTEVfQ09MT1J9T1BUSU9OUzoke19fUkVTRVRfQ09MT1J9IgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS12ZW5kb3IgPFN0cmluZz4ke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IgogICAgbG9jYWwgLWEgaGVscEFycmF5CiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwNTQKICAgIGhlbHBBcnJheT0odmVuZG9yXCBpbWFnZVwgdG9cIHVzZTpcIGFscGluZVx8dWJ1bnR1XCBcKERlZmF1bHQ6XCB1YnVudHVcKSkKICAgIGVjaG8gLWUgIiAgICAkKEFycmF5Ojp3cmFwICIgIiA3NiA0ICIke2hlbHBBcnJheVtAXX0iKSIKICAgIGVjaG8gLWUgIiAgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS0tYmFzaC12ZXJzaW9uIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KHZlcnNpb25cIG9mXCBiYXNoXCB0b1wgdXNlOlwgNC40XHw1LjBcfDUuMVx8NS4yXCBcKERlZmF1bHQ6XCA1LjFcKSkKICAgIGVjaG8gLWUgIiAgICAkKEFycmF5Ojp3cmFwICIgIiA3NiA0ICIke2hlbHBBcnJheVtAXX0iKSIKICAgIGVjaG8gLWUgIiAgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS0tYmFzaC1iYXNlLWltYWdlIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KGJhc2hcIGJhc2hcIGltYWdlXCB0b1wgdXNlXCBcKGVnOlwgdWJ1bnR1OjIwLjA0XCxcIGFtZDY0L2Jhc2g6NC40LWFscGluZTMuMThcKVwgXChEZWZhdWx0OlwgdWJ1bnR1OjIwLjA0XCkpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLWJyYW5jaC1uYW1lIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KGJyYW5jaFwgbmFtZVwgYmVpbmdcIGJ1aWx0XCxcIHdpbGxcIGhlbHBcIHRvXCBjcmVhdGVcIGRvY2tlclwgaW1hZ2VcIHRhZ1wgbmFtZSkKICAgIGVjaG8gLWUgIiAgICAkKEFycmF5Ojp3cmFwICIgIiA3NiA0ICIke2hlbHBBcnJheVtAXX0iKSIKICAgIGVjaG8gLWUgIiAgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS0tcHVzaCR7X19IRUxQX05PUk1BTH0ge3NpbmdsZX0iCiAgICBsb2NhbCAtYSBoZWxwQXJyYXkKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA1NAogICAgaGVscEFycmF5PShpZlwgcHJvdmlkZWRcLFwgcHVzaFwgdGhlXCBpbWFnZVwgdG9cIHRoZVwgcmVnaXN0cnkpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvCiAgICBlY2hvIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1HTE9CQUwgT1BUSU9OUzoke19fUkVTRVRfQ09MT1J9IgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS1iYXNoLWZyYW1ld29yay1jb25maWcgPFN0cmluZz4ke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IgogICAgbG9jYWwgLWEgaGVscEFycmF5CiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwNTQKICAgIGhlbHBBcnJheT0odXNlXCBhbHRlcm5hdGVcIGJhc2hcIGZyYW1ld29ya1wgY29uZmlndXJhdGlvbi4pCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLWNvbmZpZyR7X19IRUxQX05PUk1BTH0ge3NpbmdsZX0iCiAgICBsb2NhbCAtYSBoZWxwQXJyYXkKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA1NAogICAgaGVscEFycmF5PShEaXNwbGF5XCBjb25maWd1cmF0aW9uKQogICAgZWNobyAtZSAiICAgICQoQXJyYXk6OndyYXAgIiAiIDc2IDQgIiR7aGVscEFycmF5W0BdfSIpIgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS12ZXJib3NlJHtfX0hFTFBfTk9STUFMfSwgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS12JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KGluZm9cIGxldmVsXCB2ZXJib3NlXCBtb2RlXCBcKGFsaWFzXCBvZlwgLS1kaXNwbGF5LWxldmVsXCBJTkZPXCkpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tdnYke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IgogICAgbG9jYWwgLWEgaGVscEFycmF5CiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwNTQKICAgIGhlbHBBcnJheT0oZGVidWdcIGxldmVsXCB2ZXJib3NlXCBtb2RlXCBcKGFsaWFzXCBvZlwgLS1kaXNwbGF5LWxldmVsXCBERUJVR1wpKQogICAgZWNobyAtZSAiICAgICQoQXJyYXk6OndyYXAgIiAiIDc2IDQgIiR7aGVscEFycmF5W0BdfSIpIgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LXZ2diR7X19IRUxQX05PUk1BTH0ge3NpbmdsZX0iCiAgICBsb2NhbCAtYSBoZWxwQXJyYXkKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA1NAogICAgaGVscEFycmF5PSh0cmFjZVwgbGV2ZWxcIHZlcmJvc2VcIG1vZGVcIFwoYWxpYXNcIG9mXCAtLWRpc3BsYXktbGV2ZWxcIFRSQUNFXCkpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLWVudi1maWxlIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7bGlzdH0gKG9wdGlvbmFsKSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KExvYWRcIHRoZVwgc3BlY2lmaWVkXCBlbnZcIGZpbGUpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLW5vLWNvbG9yJHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KFByb2R1Y2VcIG1vbm9jaHJvbWVcIG91dHB1dC5cIGFsaWFzXCBvZlwgLS10aGVtZVwgbm9Db2xvci4pCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLXRoZW1lIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KGNob29zZVwgY29sb3JcIHRoZW1lXCBcKGRlZmF1bHRcLFwgZGVmYXVsdC1mb3JjZVwgb3JcIG5vQ29sb3JcKVwgLVwgZGVmYXVsdC1mb3JjZVwgbWVhbnNcIGNvbG9yc1wgd2lsbFwgYmVcIHByb2R1Y2VkXCBldmVuXCBpZlwgY29tbWFuZFwgaXNcIHBpcGVkKQogICAgZWNobyAtZSAiICAgICQoQXJyYXk6OndyYXAgIiAiIDc2IDQgIiR7aGVscEFycmF5W0BdfSIpIgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS1oZWxwJHtfX0hFTFBfTk9STUFMfSwgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS1oJHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KERpc3BsYXlcIHRoaXNcIGNvbW1hbmRcIGhlbHApCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLXZlcnNpb24ke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IgogICAgbG9jYWwgLWEgaGVscEFycmF5CiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwNTQKICAgIGhlbHBBcnJheT0oUHJpbnRcIHZlcnNpb25cIGluZm9ybWF0aW9uXCBhbmRcIHF1aXQpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLXF1aWV0JHtfX0hFTFBfTk9STUFMfSwgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS1xJHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KHF1aWV0XCBtb2RlXCxcIGRvZXNuXCd0XCBkaXNwbGF5XCBhbnlcIG91dHB1dCkKICAgIGVjaG8gLWUgIiAgICAkKEFycmF5Ojp3cmFwICIgIiA3NiA0ICIke2hlbHBBcnJheVtAXX0iKSIKICAgIGVjaG8gLWUgIiAgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS0tbG9nLWxldmVsIDxTdHJpbmc+JHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICAgIGxvY2FsIC1hIGhlbHBBcnJheQogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDU0CiAgICBoZWxwQXJyYXk9KFNldFwgbG9nXCBsZXZlbFwgXChvbmVcIG9mXCBPRkZcLFwgRVJST1JcLFwgV0FSTklOR1wsXCBJTkZPXCxcIERFQlVHXCxcIFRSQUNFXCB2YWx1ZVwpKQogICAgZWNobyAtZSAiICAgICQoQXJyYXk6OndyYXAgIiAiIDc2IDQgIiR7aGVscEFycmF5W0BdfSIpIgogICAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS1sb2ctZmlsZSA8U3RyaW5nPiR7X19IRUxQX05PUk1BTH0ge3NpbmdsZX0iCiAgICBsb2NhbCAtYSBoZWxwQXJyYXkKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA1NAogICAgaGVscEFycmF5PShTZXRcIGxvZ1wgZmlsZSkKICAgIGVjaG8gLWUgIiAgICAkKEFycmF5Ojp3cmFwICIgIiA3NiA0ICIke2hlbHBBcnJheVtAXX0iKSIKICAgIGVjaG8gLWUgIiAgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS0tZGlzcGxheS1sZXZlbCA8U3RyaW5nPiR7X19IRUxQX05PUk1BTH0ge3NpbmdsZX0iCiAgICBsb2NhbCAtYSBoZWxwQXJyYXkKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA1NAogICAgaGVscEFycmF5PShzZXRcIGRpc3BsYXlcIGxldmVsXCBcKG9uZVwgb2ZcIE9GRlwsXCBFUlJPUlwsXCBXQVJOSU5HXCxcIElORk9cLFwgREVCVUdcLFwgVFJBQ0VcIHZhbHVlXCkpCiAgICBlY2hvIC1lICIgICAgJChBcnJheTo6d3JhcCAiICIgNzYgNCAiJHtoZWxwQXJyYXlbQF19IikiCiAgICBlY2hvCiAgICBlY2hvIC1uIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1WRVJTSU9OOiAke19fUkVTRVRfQ09MT1J9IgogICAgZWNobyAnMS4wJwogICAgZWNobwogICAgZWNobyAtZSAiJHtfX0hFTFBfVElUTEVfQ09MT1J9QVVUSE9SOiR7X19SRVNFVF9DT0xPUn0iCiAgICBlY2hvICdbRnJhbsOnb2lzIENoYXN0YW5ldF0oaHR0cHM6Ly9naXRodWIuY29tL2ZjaGFzdGFuZXQpJwogICAgZWNobwogICAgZWNobyAtZSAiJHtfX0hFTFBfVElUTEVfQ09MT1J9U09VUkNFIEZJTEU6JHtfX1JFU0VUX0NPTE9SfSIKICAgIGVjaG8gJ2h0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtdG9vbHMtZnJhbWV3b3JrL3RyZWUvbWFzdGVyL3NyYy9fYmluYXJpZXMvYnVpbGRQdXNoRG9ja2VySW1hZ2Uuc2gnCiAgICBlY2hvCiAgICBlY2hvIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1MSUNFTlNFOiR7X19SRVNFVF9DT0xPUn0iCiAgICBlY2hvICdNSVQgTGljZW5zZScKICAgIGVjaG8KICAgIEFycmF5Ojp3cmFwICcgJyA3NiA0ICIkKGNvcHlyaWdodENhbGxiYWNrKSIKICBlbHNlCiAgICBMb2c6OmRpc3BsYXlFcnJvciAiQ29tbWFuZCAke1NDUklQVF9OQU1FfSAtIE9wdGlvbiBjb21tYW5kIGludmFsaWQ6ICcke29wdGlvbnNfcGFyc2VfY21kfSciCiAgICByZXR1cm4gMQogIGZpCn0KZGVjbGFyZSBjb3B5cmlnaHRCZWdpblllYXI9IjIwMjMiCgpidWlsZFB1c2hEb2NrZXJJbWFnZUNvbW1hbmQgcGFyc2UgIiR7QkFTSF9GUkFNRVdPUktfQVJHVltAXX0iCgojIGJ1aWxkIGltYWdlIGFuZCBwdXNoIGl0IG90IHJlZ2lzdHJ5CnJ1bigpIHsKICBET0NLRVJfQlVJTERfT1BUSU9OUz0iJHtET0NLRVJfQlVJTERfT1BUSU9OUzotfSIKICBCQVNIX0ZSQU1FV09SS19ST09UX0RJUj0iJHtGUkFNRVdPUktfUk9PVF9ESVJ9IgogIGlmIFtbIC1kICIkKHB3ZCkvdmVuZG9yL2Jhc2gtdG9vbHMtZnJhbWV3b3JrIiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfUk9PVF9ESVI9IiQoY2QgIiQocHdkKS92ZW5kb3IvYmFzaC10b29scy1mcmFtZXdvcmsiICYmIHB3ZCAtUCkiCiAgZmkKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQKICBsb2NhbCBpbWFnZVRhZz0iYnVpbGQ6YmFzaC10b29scy0ke29wdGlvblZlbmRvcn0tJHtvcHRpb25CYXNoVmVyc2lvbn0iCiAgbG9jYWwgaW1hZ2U9InNjcmFzbnVwcy8ke2ltYWdlVGFnfSIKCiAgTG9nOjpkaXNwbGF5SW5mbyAiUHVsbCBpbWFnZSAke2ltYWdlfSIKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQKICAoCiAgICBpZiBbWyAiJHtvcHRpb25UcmFjZVZlcmJvc2V9IiA9ICIxIiBdXTsgdGhlbgogICAgICBzZXQgLXgKICAgIGZpCiAgICBkb2NrZXIgcHVsbCAiJHtpbWFnZX0iIHx8IHRydWUKICApCgogIExvZzo6ZGlzcGxheUluZm8gIkJ1aWxkIGltYWdlICR7aW1hZ2V9IgogICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjA4NixTQzIxNTQKICAoCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQKICAgIGlmIFtbICIke29wdGlvblRyYWNlVmVyYm9zZX0iID0gIjEiIF1dOyB0aGVuCiAgICAgIHNldCAteAogICAgZmkKICAgIERPQ0tFUl9CVUlMREtJVD0xIGRvY2tlciBidWlsZCBcCiAgICAgICR7RE9DS0VSX0JVSUxEX09QVElPTlN9IFwKICAgICAgLWYgIiR7QkFTSF9GUkFNRVdPUktfUk9PVF9ESVJ9Ly5kb2NrZXIvRG9ja2VyZmlsZS4ke29wdGlvblZlbmRvcn0iIFwKICAgICAgLS1jYWNoZS1mcm9tICIke2ltYWdlfSIgXAogICAgICAtLWJ1aWxkLWFyZyBCVUlMREtJVF9JTkxJTkVfQ0FDSEU9MSBcCiAgICAgIC0tYnVpbGQtYXJnIGFyZ0Jhc2hWZXJzaW9uPSIke29wdGlvbkJhc2hWZXJzaW9ufSIgXAogICAgICAtLWJ1aWxkLWFyZyBCQVNIX0lNQUdFPSIke29wdGlvbkJhc2hCYXNlSW1hZ2V9IiBcCiAgICAgIC10ICIke2ltYWdlVGFnfSIgXAogICAgICAtdCAiJHtpbWFnZX0iIFwKICAgICAgIiR7QkFTSF9GUkFNRVdPUktfUk9PVF9ESVJ9Ly5kb2NrZXIiCiAgKQoKICBMb2c6OmRpc3BsYXlJbmZvICJJbWFnZSAke2ltYWdlfSAtIGJhc2ggdmVyc2lvbiBjaGVjayIKICBkb2NrZXIgcnVuIC0tcm0gIiR7aW1hZ2VUYWd9IiBiYXNoIC0tdmVyc2lvbgoKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQKICBpZiBbWyAiJHtvcHRpb25QdXNofSIgPSAiMSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheUluZm8gIlB1c2ggaW1hZ2UgJHtpbWFnZX0iCiAgICAoCiAgICAgIGlmIFtbICIke29wdGlvblRyYWNlVmVyYm9zZX0iID0gIjEiIF1dOyB0aGVuCiAgICAgICAgc2V0IC14CiAgICAgIGZpCiAgICAgIGRvY2tlciBwdXNoICJzY3Jhc251cHMvJHtpbWFnZVRhZ30iCiAgICApCiAgZmkKfQoKaWYgW1sgIiR7QkFTSF9GUkFNRVdPUktfUVVJRVRfTU9ERTotMH0iID0gIjEiIF1dOyB0aGVuCiAgcnVuICY+L2Rldi9udWxsCmVsc2UKICBydW4KZmkKCn0KCmZhY2FkZV9tYWluX2J1aWxkUHVzaERvY2tlckltYWdlc2ggIiRAIgo=" "755"

declare -gx embed_file_buildPushDockerImage="${PERSISTENT_TMPDIR:-/tmp}/f570a06fa3f301d870d231647c6c8b78/buildPushDockerImage"

facade_main_runBuildContainersh() {
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"
# REQUIRES
Env::requireLoad
UI::requireTheme
Log::requireLoad
Compiler::Facade::requireCommandBinDir

# @require Compiler::Facade::requireCommandBinDir

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  runBuildContainerCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 1.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERROR | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_LOG_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  BASH_FRAMEWORK_LOG_FILE="${logFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  BASH_FRAMEWORK_QUIET_MODE=1
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP='^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$'
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="^bin/|^\.framework-config$|^build.sh$|\.tpl$|/testsData/|^manualTests/|\.bats$"
# Source directories
FRAMEWORK_SRC_DIRS=(
  "${FRAMEWORK_ROOT_DIR}/src"
)

# export here all the variables that will be used in your templates
export REPOSITORY_URL="https://github.com/fchastanet/bash-tools-framework"
EOF
)"

commandOptionParseFinished() {
  if [[ -z "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    BASH_FRAMEWORK_ENV_FILES=()
  fi
  BASH_FRAMEWORK_ENV_FILES+=("${optionEnvFiles[@]}")
  export BASH_FRAMEWORK_ENV_FILES
  Env::requireLoad
  Log::requireLoad

  # load .framework-config
  if [[ -n "${optionBashFrameworkConfig}" && -f "${optionBashFrameworkConfig}" ]]; then
    BASH_FRAMEWORK_CONFIG_FILE="${optionBashFrameworkConfig}"
    # shellcheck source=/.framework-config
    source "${optionBashFrameworkConfig}" ||
      Log::fatal "Command ${SCRIPT_NAME} - error while loading specific .framework-config file: ${optionBashFrameworkConfig}"
  else
    # shellcheck disable=SC2034
    BASH_FRAMEWORK_CONFIG_FILE=""
    # shellcheck source=/.framework-config
    Framework::loadConfig BASH_FRAMEWORK_CONFIG_FILE "${FRAMEWORK_ROOT_DIR}" || {
      # load default template framework config
      if [[ ! -f "${PERSISTENT_TMPDIR}/.framework-config" ]]; then
        echo "${defaultFrameworkConfig}" > "${PERSISTENT_TMPDIR}/.framework-config"
      fi
      Framework::loadConfig BASH_FRAMEWORK_CONFIG_FILE "${PERSISTENT_TMPDIR}" || {
        Log::fatal "Command ${SCRIPT_NAME} - error while loading .framework-config.default file"
      }
      Log::displayWarning "Command ${SCRIPT_NAME} - Load default .framework-config file - ${PERSISTENT_TMPDIR}/.framework-config"
    }
  fi

  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

# shellcheck disable=SC2317 # if function is overridden
updateOptionVendorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1" "$2")
}

# shellcheck disable=SC2317 # if function is overridden
updateOptionBashVersionCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1" "$2")
}

# shellcheck disable=SC2317 # if function is overridden
updateOptionBashBaseImageCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1" "$2")
}

# shellcheck disable=SC2317 # if function is overridden
updateOptionBranchNameCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1" "$2")
}

declare optionVendor="ubuntu"
declare optionBashVersion="5.1"
declare optionBashBaseImage="ubuntu:20.04"
declare optionContinuousIntegrationMode=0

# shellcheck disable=SC2317 # if function is overridden
updateOptionContinuousIntegrationMode() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1")
}

declare optionSkipDockerBuild=0

# shellcheck disable=SC2317 # if function is overridden
updateOptionSkipDockerBuildCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=("$1")
}

runBuildContainerCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    local -i options_parse_optionParsedCountOptionVendor
    ((options_parse_optionParsedCountOptionVendor = 0)) || true
    local -i options_parse_optionParsedCountOptionBashVersion
    ((options_parse_optionParsedCountOptionBashVersion = 0)) || true
    local -i options_parse_optionParsedCountOptionBashBaseImage
    ((options_parse_optionParsedCountOptionBashBaseImage = 0)) || true
    local -i options_parse_optionParsedCountOptionBranchName
    ((options_parse_optionParsedCountOptionBranchName = 0)) || true
    optionContinuousIntegrationMode="0"
    local -i options_parse_optionParsedCountOptionContinuousIntegrationMode
    ((options_parse_optionParsedCountOptionContinuousIntegrationMode = 0)) || true
    optionSkipDockerBuild="0"
    local -i options_parse_optionParsedCountOptionSkipDockerBuild
    ((options_parse_optionParsedCountOptionSkipDockerBuild = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    local -i options_parse_argParsedCountDockerRunCmd
    ((options_parse_argParsedCountDockerRunCmd = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/20
        # Option optionVendor --vendor variableType String min 0 max 1 authorizedValues 'alpine|ubuntu' regexp ''
        --vendor)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ alpine|ubuntu ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(alpine|ubuntu)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionVendor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVendor))
          # shellcheck disable=SC2034
          optionVendor="$1"
          updateOptionVendorCallback "${options_parse_arg}" "${optionVendor}"
          ;;
        # Option 2/20
        # Option optionBashVersion --bash-version variableType String min 0 max 1 authorizedValues '4.4|5.0|5.1|5.2' regexp ''
        --bash-version)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ 4.4|5.0|5.1|5.2 ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(4.4|5.0|5.1|5.2)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashVersion))
          # shellcheck disable=SC2034
          optionBashVersion="$1"
          updateOptionBashVersionCallback "${options_parse_arg}" "${optionBashVersion}"
          ;;
        # Option 3/20
        # Option optionBashBaseImage --bash-base-image variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-base-image)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashBaseImage >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashBaseImage))
          # shellcheck disable=SC2034
          optionBashBaseImage="$1"
          updateOptionBashBaseImageCallback "${options_parse_arg}" "${optionBashBaseImage}"
          ;;
        # Option 4/20
        # Option optionBranchName --branch-name variableType String min 0 max 1 authorizedValues '' regexp ''
        --branch-name)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBranchName >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBranchName))
          # shellcheck disable=SC2034
          optionBranchName="$1"
          updateOptionBranchNameCallback "${options_parse_arg}" "${optionBranchName}"
          ;;
        # Option 5/20
        # Option optionContinuousIntegrationMode --ci variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --ci)
          # shellcheck disable=SC2034
          optionContinuousIntegrationMode="1"
          if ((options_parse_optionParsedCountOptionContinuousIntegrationMode >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionContinuousIntegrationMode))
          updateOptionContinuousIntegrationMode "${options_parse_arg}"
          ;;
        # Option 6/20
        # Option optionSkipDockerBuild --skip-docker-build variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-docker-build)
          # shellcheck disable=SC2034
          optionSkipDockerBuild="1"
          if ((options_parse_optionParsedCountOptionSkipDockerBuild >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionSkipDockerBuild))
          updateOptionSkipDockerBuildCallback "${options_parse_arg}"
          ;;
        # Option 7/20
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 8/20
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 9/20
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/20
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 11/20
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 12/20
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 13/20
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 14/20
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 15/20
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 16/20
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 17/20
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 18/20
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 19/20
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 20/20
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          unknownOption "${options_parse_arg}"
          ;;
        *)
          if ((0)); then
            # Technical if - never reached
            :
          # Argument 1/1
          # Argument dockerRunCmd min 0 max -1 authorizedValues '' regexp ''
          elif ((options_parse_parsedArgIndex >= 0)); then
            ((++options_parse_argParsedCountDockerRunCmd))
            # shellcheck disable=SC2034
            dockerRunCmd+=("${options_parse_arg}")
          else
            if [[ "${argOptDefaultBehavior}" = "0" ]]; then
              Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
              return 1
            fi
          fi
          ((++options_parse_parsedArgIndex))
          ;;
      esac
      shift || true
    done
    commandOptionParseFinished
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    echo -e "$(Array::wrap " " 80 0 "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}" "run the container eventually building the docker image before.")"
    echo

    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]" "[ARGUMENTS]")"
    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--vendor <String>]" "[--bash-version <String>]" "[--bash-base-image <String>]" "[--branch-name <String>]" "[--ci]" "[--skip-docker-build]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"
    echo -e "  [${__HELP_OPTION_COLOR}arg${__HELP_NORMAL} {list} (optional)]"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(command\ arguments\ including\ command\ name)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--vendor <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(vendor\ image\ to\ use:\ alpine\|ubuntu\ \(Default:\ ubuntu\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-version <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(version\ of\ bash\ to\ use:\ 4.4\|5.0\|5.1\|5.2\ \(Default:\ 5.1\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-base-image <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(bash\ bash\ image\ to\ use\ \(eg:\ ubuntu:20.04\,\ amd64/bash:4.4-alpine3.18\)\ \(Default:\ ubuntu:20.04\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--branch-name <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(branch\ name\ being\ built\,\ will\ help\ to\ create\ docker\ image\ tag\ name)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--ci${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(activate\ continuous\ integration\ mode\ \(tmp\ folder\ not\ shared\ with\ host\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-docker-build${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ docker\ image\ build\ if\ option\ provided)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ \(default\,\ default-force\ or\ noColor\)\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e """
run the container specified by args provided.
Command to run is passed via the rest of arguments.
TTY allocation is detected automatically.

additional env variables can be passed to docker build:
  - ${__HELP_OPTION_COLOR}SKIP_USER${__HELP_NORMAL} (default: 0)
  - ${__HELP_OPTION_COLOR}USER_ID${__HELP_NORMAL} (default: current user id provided by (id -u) command)
  - ${__HELP_OPTION_COLOR}GROUP_ID${__HELP_NORMAL} (default: current group id provided by (id -g) command)

additional docker run options can be passed
  via ${__HELP_OPTION_COLOR}DOCKER_RUN_OPTIONS${__HELP_NORMAL} env variable"""
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '1.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[Franois Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/runBuildContainer.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}
declare copyrightBeginYear="2022"

# shellcheck disable=SC2317 # if function is overridden
unknownOption() {
  dockerRunCmd+=("$1")
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  RUN_CONTAINER_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  RUN_CONTAINER_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  RUN_CONTAINER_ARGV_FILTERED+=(-vvv)
}

declare -a dockerRunCmd=()
declare -a dockerRunArgs=()
declare -a dockerRunArgs=(
  -e KEEP_TEMP_FILES="${KEEP_TEMP_FILES}"
  -e BATS_FIX_TEST="${BATS_FIX_TEST:-0}"
)
export DOCKER_BUILD_OPTIONS="${DOCKER_BUILD_OPTIONS:-}"
export DOCKER_RUN_OPTIONS="${DOCKER_RUN_OPTIONS:-}"
export BASH_FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR}"

runBuildContainerCommand parse "${BASH_FRAMEWORK_ARGV[@]}"

if tty -s; then
  dockerRunArgs+=("-it")
fi
if [[ -d "$(pwd)/vendor/bash-tools-framework" ]]; then
  BASH_FRAMEWORK_ROOT_DIR="$(cd "$(pwd)/vendor/bash-tools-framework" && pwd -P)"
  dockerRunArgs+=(
    -v "${BASH_FRAMEWORK_ROOT_DIR}:/bash/vendor/bash-tools-framework"
  )
fi

# shellcheck disable=SC2154
if [[ "${optionContinuousIntegrationMode}" = "0" ]]; then
  dockerRunArgs+=(-v "/tmp:/tmp")
fi

run() {
  # shellcheck disable=SC2154
  Log::displayInfo "Using ${optionVendor}:${optionBashVersion}"

  imageRef="bash-tools-${optionVendor}-${optionBashVersion}"
  if [[ "${optionSkipDockerBuild:-0}" != "1" ]]; then
    Log::displayInfo "Build docker image ${imageRef}"
    # shellcheck disable=SC2154
    (
      if [[ "${optionTraceVerbose}" = "1" ]]; then
        set -x
      fi
      EMBED_CURRENT_DIR="${CURRENT_DIR}" "${embed_file_buildPushDockerImage}" \
        --vendor "${optionVendor}" \
        --bash-version "${optionBashVersion}" \
        --bash-base-image "${optionBashBaseImage}" \
        "${RUN_CONTAINER_ARGV_FILTERED[@]}"
    )
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.docker/DockerfileUser" ]]; then
    local imageRefUser="${imageRef}-user"
    if [[ "${optionSkipDockerBuild:-0}" != "1" ]]; then
      Log::displayInfo "build docker image ${imageRefUser} with user configuration"
      # shellcheck disable=SC2154
      (
        if [[ "${optionTraceVerbose}" = "1" ]]; then
          set -x
        fi
        # shellcheck disable=SC2086
        DOCKER_BUILDKIT=1 docker build \
          ${DOCKER_BUILD_OPTIONS} \
          --cache-from "scrasnups/build:${imageRef}" \
          --build-arg "BASH_IMAGE=scrasnups/build:${imageRef}" \
          --build-arg SKIP_USER="${SKIP_USER:-0}" \
          --build-arg USER_ID="${USER_ID:-$(id -u)}" \
          --build-arg GROUP_ID="${GROUP_ID:-$(id -g)}" \
          -f "${FRAMEWORK_ROOT_DIR}/.docker/DockerfileUser" \
          -t "${imageRefUser}" \
          "${FRAMEWORK_ROOT_DIR}/.docker"
      )
    fi
  fi

  Log::displayInfo "Run container with command: '${dockerRunCmd[*]} ${RUN_CONTAINER_ARGV_FILTERED[*]}'"
  (
    # shellcheck disable=SC2154
    if [[ "${optionTraceVerbose}" = "1" ]]; then
      set -x
    fi
    # shellcheck disable=SC2086
    docker run \
      --rm \
      ${DOCKER_RUN_OPTIONS} \
      "${dockerRunArgs[@]}" \
      -w /bash \
      -v "$(pwd):/bash" \
      --user "${USER_ID:-$(id -u)}:${GROUP_ID:-$(id -g)}" \
      "${imageRefUser}" \
      "${dockerRunCmd[@]}" \
      "${RUN_CONTAINER_ARGV_FILTERED[@]}"
  )
}

if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
  run &>/dev/null
else
  run
fi

}

facade_main_runBuildContainersh "$@"
