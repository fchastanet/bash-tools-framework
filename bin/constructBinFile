#!/usr/bin/env bash

BIN_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
ROOT_DIR="$(cd "${BIN_DIR}/.." && pwd -P)"
SRC_DIR="$(cd "${ROOT_DIR}/src" && pwd -P)"
export FRAMEWORK_DIR="${ROOT_DIR}"

# shellcheck source=src/_includes/_header.sh
source "${SRC_DIR}/_includes/_header.sh"
# shellcheck source=src/Env/load.sh
source "${SRC_DIR}/Env/load.sh"
# shellcheck source=src/Log/__all.sh
source "${SRC_DIR}/Log/__all.sh"
# shellcheck source=src/File/upFind.sh
source "${SRC_DIR}/File/upFind.sh"
# shellcheck source=src/Array/contains.sh
source "${SRC_DIR}/Array/contains.sh"
# shellcheck source=src/Filters/bashFrameworkFunctions.sh
source "${SRC_DIR}/Filters/bashFrameworkFunctions.sh"
# shellcheck source=/src/Conf/loadNearestFile.sh
source "${SRC_DIR}/Conf/loadNearestFile.sh"
# shellcheck source=src/Framework/loadConfig.sh
source "${SRC_DIR}/Framework/loadConfig.sh"

# Usage info
showHelp() {
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} create binary file from a srcFile

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} {srcFile} {templateDir} {binDir} {rootDir} [{srcDirs}]

  --help,-h : prints this help and exits
  srcFile     : file that needs to be compiled
  templateDir : directory from which bash-tpl templates will be searched
  binDir      : fallback bin directory in case BIN_FILE has not been provided
  rootDir     : directory used to compute src file relative path
  srcDirs : (optional) you can provide multiple directories where to find the
                functions source code additionally to the bash-tools-framework/src directory

srcFile should contains metadata BIN_FILE and ROOT_DIR_RELATIVE_TO_BIN_DIR at
top of the bash script file (see example below)

${__HELP_TITLE}ROOT_DIR_RELATIVE_TO_BIN_DIR metadata:${__HELP_NORMAL}
Mandatory information allowing the compiler to deduce bash-tools-framework root directory.

${__HELP_TITLE}BIN_FILE metadata (optional):${__HELP_NORMAL}
allows to indicate where the resulting bin file will be generated
if not provided, the binary file will be copied to {binDir} without sh extension

${__HELP_TITLE}INCLUDE metadata (optional):${__HELP_NORMAL}
${__HELP_EXAMPLE}Syntax: # INCLUDE "srcFile" AS "targetFile"${__HELP_NORMAL}
${__HELP_EXAMPLE}Syntax: # INCLUDE "srcDir" AS "targetDir"${__HELP_NORMAL}
${__HELP_EXAMPLE}Syntax: # INCLUDE namespace::functions AS "myFunction"${__HELP_NORMAL}
if INCLUDE metadata is provided, the file/dir provided will be added inside the resulting
bin file as a tar gz file(base64 encoded) and automatically extracted when executed.

${__HELP_TITLE}File header example:${__HELP_NORMAL}${__HELP_EXAMPLE}
#!/usr/bin/env bash
# BIN_FILE=\${ROOT_DIR}/bin/myBinary
# ROOT_DIR_RELATIVE_TO_BIN_DIR=..
# META_SCRIPT=MinimumRequirements
# INCLUDE "\${ROOT_DIR}/bin/otherNeededBinary" AS "\${BIN_DIR}/otherNeededBinary"
# INCLUDE Backup::file AS "\${BIN_DIR}/backupFile"
sudo "\${BIN_DIR}/backupFile" ...
"\${BIN_DIR}/otherNeededBinary"${__HELP_NORMAL}

$(SRC_FILE_PATH=bin/constructBinFile envsubst <"${SRC_DIR}/_includes/authorHardCoded.tpl")
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help -o h -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done

declare srcFile="$1"
declare templateDir="$2"
declare binDir="$3"
declare rootDir="$4"
shift 4 || true
declare -a srcDirs=("$@")
srcDirs+=("${SRC_DIR}")

# load .framework-config
configFile=""
# shellcheck source=/.framework-config
Framework::loadConfig configFile "${srcDirs[@]}" || Log::fatal "error while loading .framework-config file"

getBinFileFromSrcFile() {
  local srcFile="$1"
  local binDir="$2"
  local rootDir="$3"
  local BIN_FILE

  BIN_FILE="$(grep -E '# BIN_FILE=' "${srcFile}" | sed -E 's/^#[^=]+=[ \t]*(.*)[ \t]*$/\1/' || :)"
  BIN_FILE="$(echo "${BIN_FILE}" | ROOT_DIR="${rootDir}" envsubst)"
  if [[ -z "${BIN_FILE}" ]]; then
    Log::displaySkipped "${srcFile} does not contains BIN_FILE metadata"
    return 0
  fi
  mkdir -p "$(dirname "${BIN_FILE}")" || true
  if ! realpath "${BIN_FILE}" &>/dev/null; then
    Log::displayError "${srcFile} does not define a valid BIN_FILE value"
    return 1
  fi
  echo "${BIN_FILE}"
}

getRootDirRelativeToBinDirFromSrcFile() {
  local srcFile="$1"
  grep -E '# ROOT_DIR_RELATIVE_TO_BIN_DIR=' "${srcFile}" | sed -E 's/^#[^=]+=[ \t]*(.*)[ \t]*$/\1/' || :
}

removeConstructBinFileMetaDataFilter() {
  sed -E '/^# (BIN_FILE=|ROOT_DIR_RELATIVE_TO_BIN_DIR=|INCLUDE ).*$/d'
}

removeAllMetaDataFilter() {
  sed -E '/^# (BIN_FILE=|ROOT_DIR_RELATIVE_TO_BIN_DIR=|META_[^=]*=|INCLUDE ).*$/d'
}

getFileRelativeToDir() {
  local srcFile="$1"
  local relativeTo="$2"

  realpath -m --relative-to="${relativeTo}" "${srcFile}"
}

constructBinFile() {
  local srcFile="$1"
  local templateDir="$2"
  local binDir="$3"
  local rootDir="$4"

  local BIN_FILE
  BIN_FILE=$(getBinFileFromSrcFile "${srcFile}" "${binDir}" "${rootDir}")
  if [[ -z "${BIN_FILE}" ]]; then
    # BIN_FILE metadata not provided => skipped
    return 0
  fi
  mkdir -p "$(realpath -m "$(dirname "${BIN_FILE}")")" || true
  Log::displayInfo "Binfile ${BIN_FILE} from ${srcFile}"

  # pass through an intermediate file to avoid bash tools framewwork functions injection
  # that could be implied by INCLUDE usage (eg: INCLUDE Backup::file)
  local TEMP_SRC_FILE
  TEMP_SRC_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t bash-tools-constructBinFiles-before-XXXXXX)"
  removeConstructBinFileMetaDataFilter <"${srcFile}" >"${TEMP_SRC_FILE}"
  Log::displayDebug "Binfile ${BIN_FILE} Writing intermediate src file without metadata from ${srcFile}"

  Log::displayInfo "Binfile ${BIN_FILE} from ${srcFile}"
  local -a compileArgs=(
    "${TEMP_SRC_FILE}"
    "$(getFileRelativeToDir "${srcFile}" "${rootDir}")"
    "$(getRootDirRelativeToBinDirFromSrcFile "${srcFile}")"
    "${rootDir}"
    --template-dir "${templateDir}"
  )
  for srcDir in "${srcDirs[@]}"; do
    compileArgs+=(--src-dir "${srcDir}")
  done
  "${BIN_DIR}/compile" "${compileArgs[@]}" |
    removeAllMetaDataFilter >"${BIN_FILE}"
  chmod +x "${BIN_FILE}"
}

constructBinFile "${srcFile}" "${templateDir}" "${binDir}" "${rootDir}"
