#!/usr/bin/env bash

# generate code from templates <https://github.com/TekWizely/bash-tpl>
#  - auto import function with pattern folder::(._::)_(functionName) =>
#    Folder/functionName.sh
#  - auto import \_.sh before if at least one function imported in the directory
#  - auto import ZZZ.sh after loading functions if at least one function imported in the directory

_COMPILE_BIN_DIR="$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)"
_COMPILE_ROOT_DIR="$(cd "${_COMPILE_BIN_DIR}/.." && pwd -P)"
_COMPILE_SRC_DIR="$(cd "${_COMPILE_ROOT_DIR}/src" && pwd -P)"
export FRAMEWORK_DIR="${_COMPILE_ROOT_DIR}"

# shellcheck source=/src/_includes/_header.sh
source "${_COMPILE_SRC_DIR}/_includes/_header.sh"
# shellcheck source=/src/Array/contains.sh
source "${_COMPILE_SRC_DIR}/Array/contains.sh"
# shellcheck source=/src/Assert/validPath.sh
source "${_COMPILE_SRC_DIR}/Assert/validPath.sh"
# shellcheck source=/src/File/upFind.sh
source "${_COMPILE_SRC_DIR}/File/upFind.sh"
# shellcheck source=/src/Conf/loadNearestFile.sh
source "${_COMPILE_SRC_DIR}/Conf/loadNearestFile.sh"
# shellcheck source=/src/Framework/loadConfig.sh
source "${_COMPILE_SRC_DIR}/Framework/loadConfig.sh"
# shellcheck source=src/Env/load.sh
source "${_COMPILE_SRC_DIR}/Env/load.sh"
# shellcheck source=src/File/upFind.sh
source "${_COMPILE_SRC_DIR}/File/upFind.sh"
# shellcheck source=src/File/relativeToDir.sh
source "${_COMPILE_SRC_DIR}/File/relativeToDir.sh"
# shellcheck source=/src/Filters/removeDuplicatedShebangs.sh
source "${_COMPILE_SRC_DIR}/Filters/removeDuplicatedShebangs.sh"
# shellcheck source=/src/Filters/catFileCleaned.sh
source "${_COMPILE_SRC_DIR}/Filters/catFileCleaned.sh"
# shellcheck source=/src/Filters/trimEmptyLines.sh
source "${_COMPILE_SRC_DIR}/Filters/trimEmptyLines.sh"
# shellcheck source=/src/Filters/bashFrameworkFunctions.sh
source "${_COMPILE_SRC_DIR}/Filters/bashFrameworkFunctions.sh"
# shellcheck source=/src/Filters/commentLines.sh
source "${_COMPILE_SRC_DIR}/Filters/commentLines.sh"
# shellcheck source=/src/Filters/directive.sh
source "${_COMPILE_SRC_DIR}/Filters/directive.sh"
# shellcheck source=/src/Filters/directiveValue.sh
source "${_COMPILE_SRC_DIR}/Filters/directiveValue.sh"
# shellcheck source=/src/Compiler/extractVarForExport.sh
source "${_COMPILE_SRC_DIR}/Compiler/extractVarForExport.sh"
# shellcheck source=/src/Compiler/extractUniqueFrameworkFunctions.sh
source "${_COMPILE_SRC_DIR}/Compiler/extractUniqueFrameworkFunctions.sh"
# shellcheck source=/src/Compiler/findFunctionInSrcDirs.sh
source "${_COMPILE_SRC_DIR}/Compiler/findFunctionInSrcDirs.sh"
# shellcheck source=/src/Compiler/getBinFile.sh
source "${_COMPILE_SRC_DIR}/Compiler/getBinFile.sh"
# shellcheck source=/src/Compiler/injectFileOnce.sh
source "${_COMPILE_SRC_DIR}/Compiler/injectFileOnce.sh"
# shellcheck source=/src/File/insertFileBeforeToken.sh
source "${_COMPILE_SRC_DIR}/File/insertFileBeforeToken.sh"
# shellcheck source=/src/File/insertFileAfterToken.sh
source "${_COMPILE_SRC_DIR}/File/insertFileAfterToken.sh"
# shellcheck source=src/Embed/inject.sh
source "${_COMPILE_SRC_DIR}/Embed/inject.sh"
# shellcheck source=src/Embed/filter.sh
source "${_COMPILE_SRC_DIR}/Embed/filter.sh"
# shellcheck source=src/Embed/parse.sh
source "${_COMPILE_SRC_DIR}/Embed/parse.sh"
# shellcheck source=src/Embed/assertAsName.sh
source "${_COMPILE_SRC_DIR}/Embed/assertAsName.sh"
# shellcheck source=src/Embed/assertResource.sh
source "${_COMPILE_SRC_DIR}/Embed/assertResource.sh"
# shellcheck source=src/Embed/embed.sh
source "${_COMPILE_SRC_DIR}/Embed/embed.sh"
# shellcheck source=src/Assert/validVariableName.sh
source "${_COMPILE_SRC_DIR}/Assert/validVariableName.sh"
# shellcheck source=src/Embed/embedFile.sh
source "${_COMPILE_SRC_DIR}/Embed/embedFile.sh"
# shellcheck source=src/Embed/embedDir.sh
source "${_COMPILE_SRC_DIR}/Embed/embedDir.sh"
# shellcheck source=src/Embed/embedFrameworkFunction.sh
source "${_COMPILE_SRC_DIR}/Embed/embedFrameworkFunction.sh"
# shellcheck source=src/Filters/removeExternalQuotes.sh
source "${_COMPILE_SRC_DIR}/Filters/removeExternalQuotes.sh"
# shellcheck source=/src/Assert/bashFrameworkFunction.sh
source "${_COMPILE_SRC_DIR}/Assert/bashFrameworkFunction.sh"
# shellcheck source=/src/Assert/fileWritable.sh
source "${_COMPILE_SRC_DIR}/Assert/fileWritable.sh"
# shellcheck source=/src/Embed/getSrcDirsFromOptions.sh
source "${_COMPILE_SRC_DIR}/Embed/getSrcDirsFromOptions.sh"

# shellcheck disable=SC2034
((failures = 0)) || true
declare -a srcDirs=()
# shellcheck disable=SC2034
ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
# root dir absolute path
ROOT_DIR="${_COMPILE_ROOT_DIR}"
BIN_FILE=""
export BIN_FILE

################################################
# Parse options
################################################
# Usage info
showHelp() {
  SCRIPT_NAME=${0##*/}
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} inlines all the functions used in the
script given in parameter

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} <fileToCompile>
    [--src-dir|-s <srcDir>] [--bin-dir|-b <binDir>] [--bin-file|-f <binFile>]
    [--root-dir|-r <rootDir>] [--src-path <srcPath>]
    [--template <templateName>] [--keep-temp-files|-k]

${__HELP_TITLE}Mandatory Arguments:${__HELP_NORMAL}

    <fileToCompile> the relative or absolute path to compile into
      one file

${__HELP_TITLE}Options:${__HELP_NORMAL}
    --help,-h prints this help and exits

    --src-dir|-s <srcDir> provide the directory where to find the
      functions source code.

    --bin-dir|-b <binDir> allows to override the value of BIN_DIR
      by default BIN_DIR is set to '${ROOT_DIR}/bin'

    --bin-file|-f <binFile> BIN_FILE directive will be overridden
      by binFile value

    --template-dir|-t <templateDir> the template directory to use
      to override some template includes.

    --root-dir|-r <rootDir> if you whish to override ROOT_DIR
      variable (default value is '${ROOT_DIR}'

    --src-path <path> if you wish to override the filepath that will
      be displayed in the header to indicate the src filepath that
      has been compiled (SRC_FILE_PATH).
      By default, it is initialized with path relative to ROOT_DIR

    --keep-temp-files|-k keep temporary files for debug purpose

${__HELP_TITLE}More information on options and directives:${__HELP_NORMAL}
  You can find more information on
  https://fchastanet.github.io/bash-tools-framework/#/CompileCommand?id=compileCommandHelp

$(SRC_FILE_PATH=bin/compile envsubst <"${_COMPILE_SRC_DIR}/_includes/authorHardCoded.tpl")
EOF
}

# share this command arguments to allow Embed to compile files using same
# parameters
declare -agx _COMPILE_FILE_ARGUMENTS=()

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
longOpts="help,src-dir:,template-dir:,bin-dir:,root-dir:,src-path:,bin-file:,keep-temp-files"
shortOpts="hks:t:b:r:f:"
options=$(getopt -l "${longOpts}" -o "${shortOpts}" -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --src-dir | -s)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      _COMPILE_FILE_ARGUMENTS+=(-s "$1")
      srcDirs+=("$(realpath --physical "$1")")
      ;;
    --template-dir | -t)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      _COMPILE_FILE_ARGUMENTS+=(-t "$1")
      TEMPLATE_DIR="$(realpath --physical "$1")"
      ;;
    --bin-dir | -b)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      _COMPILE_FILE_ARGUMENTS+=(-b "$1")
      BIN_DIR="$(realpath --physical "$1")"
      ;;
    --bin-file | -f)
      shift || true
      if ! Assert::validPath "$1"; then
        Log::fatal "Bin file path '$1' is not a valid path"
      fi
      _COMPILE_FILE_ARGUMENTS+=(-f "$1")
      BIN_FILE="$1"
      ;;
    --root-dir | -r)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      _COMPILE_FILE_ARGUMENTS+=(-r "$1")
      ROOT_DIR="$(realpath --physical "$1")"
      ;;
    --src-path)
      shift || true
      if ! Assert::validPath "$1"; then
        Log::fatal "Src path '$1' is not a valid path"
      fi
      SRC_FILE_PATH="$1"
      ;;
    --keep-temp-files | -k)
      KEEP_TEMP_FILES=1
      _COMPILE_FILE_ARGUMENTS+=(-k)
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done
# add framework src dir by default
srcDirs+=("${_COMPILE_SRC_DIR}")
_COMPILE_FILE_ARGUMENTS+=(-s "${_COMPILE_SRC_DIR}")

if (($# != 1)); then
  Log::fatal "You must provide exactly 1 fixed parameter"
fi

# The file to compile
INPUT_FILE="$1"

# if bin dir has not been set, set a default value
if [[ -z "${BIN_DIR+xxx}" ]]; then
  BIN_DIR="${ROOT_DIR}/bin"
fi
export BIN_DIR
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP=^$
loggedMessages=()

# load .framework-config
configFile=""
# shellcheck source=/.framework-config
Framework::loadConfig configFile "${srcDirs[@]}" || Log::fatal "error while loading .framework-config file"

# shellcheck disable=SC2317
dynamicTemplateDir() {
  local file="$1"
  if [[ -f "${TEMPLATE_DIR}/${file}" ]]; then
    echo "${TEMPLATE_DIR}/${file}"
    return 0
  elif [[ -f "${ORIGINAL_TEMPLATE_DIR}/${file}" ]]; then
    echo "${ORIGINAL_TEMPLATE_DIR}/${file}"
    return 0
  fi
  local msg="dynamicTemplateDir - ${file} does not exist in any template dirs declared"
  echo -e "\e[31m${msg}\e[0m" >&2
  return 1
}
export -f dynamicTemplateDir

# shellcheck disable=SC2317
dynamicSrcFile() {
  local file="$1"
  local -a srcDirs=()
  readarray -t srcDirs <"${TMPDIR:-/tmp}/srcDirs"
  for srcDir in "${srcDirs[@]}"; do
    if [[ -f "${srcDir}/${file}" ]]; then
      echo "${srcDir}/${file}"
      return 0
    fi
  done
  local msg="dynamicSrcFile - ${file} does not exist in any src dirs declared"
  echo -e "\e[31m${msg}\e[0m" >&2
  return 1
}
export -f dynamicSrcFile

# shellcheck disable=SC2317
dynamicSrcDir() {
  local dir="$1"
  local -a srcDirs=()
  readarray -t srcDirs <"${TMPDIR:-/tmp}/srcDirs"
  for srcDir in "${srcDirs[@]}"; do
    if [[ -d "${srcDir}/${dir}" ]]; then
      echo "${srcDir}/${dir}"
      return 0
    fi
  done
  local msg="dynamicSrcDir - ${dir} does not exist in any src dirs declared"
  echo -e "\e[31m${msg}\e[0m" >&2
  return 1
}
export -f dynamicSrcDir

evalTemplate() {
  local FILE="$1"
  local varExports
  varExports="$(Compiler::extractVarForExport "${FILE}")"

  # the src file you want to show at the top of generated file to indicate
  # from which source file the binary has been generated
  if [[ -z "${SRC_FILE_PATH+xxx}" ]]; then
    SRC_FILE_PATH="$(File::relativeToDir "${INPUT_FILE}" "${ROOT_DIR}")"
  fi

  SRC_ABSOLUTE_PATH="$(realpath "${INPUT_FILE}")"
  (
    cd "${TEMPLATE_DIR}"
    eval "${varExports}"
    ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
    export BIN_DIR
    export ROOT_DIR
    export ORIGINAL_TEMPLATE_DIR
    export TEMPLATE_DIR
    export SRC_ABSOLUTE_PATH
    export SRC_FILE_PATH
    export ROOT_DIR_RELATIVE_TO_BIN_DIR
    export TMPDIR
    # make srcDirs array available for dynamicSrcFile and dynamicSrcDir
    trap 'rm -f "${TMPDIR:-/tmp}/srcDirs"' INT EXIT HUP QUIT ABRT TERM
    printf '%s\n' "${srcDirs[@]}" >"${TMPDIR:-/tmp}/srcDirs"
    # shellcheck source=/dev/null
    source <("${_COMPILE_ROOT_DIR}/bin/bash-tpl" "${FILE}")
  ) | Filters::removeDuplicatedShebangs
}

importFunctions() {
  local file="$1"
  local importedFunctionsTempFile="$2"
  local importedZZZTempFile="$3"
  local -n filesImportedWithFunctions=$4
  local -n newFilesAdded=$5
  local -n importFailures=$6
  local -a functionsToImport
  local functionToImport

  readarray -t functionsToImport < <(Compiler::extractUniqueFrameworkFunctions "${file}")

  ((newFilesAdded = 0)) || true
  if [[ "${ARGS_VERBOSE:-0}" = "2" ]]; then
    Log::displayDebug "importing ${file} with ${#functionsToImport[@]} functions to import"
  fi
  for functionToImport in "${functionsToImport[@]}"; do
    if echo "${functionToImport}" | grep -q -E "${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP}"; then
      if [[ "${ARGS_VERBOSE:-0}" = "1" ]]; then
        msg="File ${INPUT_FILE} Function ${functionToImport} ignored, because of rule defined in ${configFile}"
        if ! Array::contains "${msg}" "${loggedMessages[@]}"; then
          loggedMessages+=("${msg}")
          Log::displayHelp "${msg}" "HINT"
        fi
      fi
      continue
    fi

    local fileToImport
    fileToImport="$(Compiler::findFunctionInSrcDirs "${functionToImport}" "${srcDirs[@]}")" || {
      Log::displayError "File ${INPUT_FILE} Function ${functionToImport} not found in any src directories"
      ((importFailures++)) || true
      continue
    }

    if Array::contains "${fileToImport}" "${filesImportedWithFunctions[@]}"; then
      continue
    fi

    if [[ -f "${fileToImport}" ]]; then
      local fileToImportDir
      fileToImportDir="$(dirname "${fileToImport}")"
      # check if we need to import _.sh
      if [[ -f "${fileToImportDir}/_.sh" ]]; then
        Compiler::injectFileOnce "${fileToImportDir}/_.sh" \
          filesImportedWithFunctions >>"${importedFunctionsTempFile}"
      fi
      # check if we need to import ZZZ.sh
      if [[ -f "${fileToImportDir}/ZZZ.sh" ]]; then
        Compiler::injectFileOnce "${fileToImportDir}/ZZZ.sh" \
          filesImportedWithFunctions >>"${importedZZZTempFile}"
      fi
      Compiler::injectFileOnce "${fileToImport}" \
        filesImportedWithFunctions >>"${importedFunctionsTempFile}"

      # shellcheck disable=SC2034
      ((newFilesAdded = 1)) # as we added some files, we need to do another pass
    else
      Log::displayError "File ${INPUT_FILE} File ${fileToImport} does not exist${__RESET_COLOR}"
      # even if not existing, consider the file as imported to avoid other same errors
      filesImportedWithFunctions+=("${fileToImport}")
      ((importFailures++)) || true
    fi
  done
}

injectImportedFunctions() {
  local file="$1"
  # shellcheck disable=SC2034
  local -n filesImported=$2

  local needAnotherPass
  local -a functionsToImport
  local iteration
  local fileToImport

  local importedFunctionsTempFile
  importedFunctionsTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_functions.XXXXXXX")"
  local importedZZZTempFile
  importedZZZTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_zzz_files.XXXXXXX")"

  ((needAnotherPass = 1))
  ((iteration = 1))
  while ((needAnotherPass >= 1)); do
    if [[ "${ARGS_VERBOSE:-0}" = "2" ]]; then
      Log::displayDebug "File ${INPUT_FILE} Iteration #${iteration}"
    fi
    echo >"${importedFunctionsTempFile}"
    echo >"${importedZZZTempFile}"

    importFunctions "${file}" "${importedFunctionsTempFile}" "${importedZZZTempFile}" \
      filesImported needAnotherPass failures

    # insert functions before # FUNCTIONS
    File::insertFileBeforeToken "${file}" "${importedFunctionsTempFile}" "# FUNCTIONS"

    # insert zzz files after # FUNCTIONS
    File::insertFileAfterToken "${file}" "${importedZZZTempFile}" "# FUNCTIONS"

    ((iteration++))
  done
}

injectEmbed() {
  local file="$1"
  local embedFile
  embedFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "embed_file.XXXXXXX")"
  local -a _EMBED_COMPILE_ARGUMENTS=("${_COMPILE_FILE_ARGUMENTS[@]}")
  # shellcheck disable=SC2034
  local -a embeddedNames=()
  # shellcheck disable=SC2034
  local -a embeddedResources=()
  Embed::inject embeddedNames embeddedResources <"${file}" >"${embedFile}"
  File::insertFileAfterToken "${file}" "${embedFile}" "# FUNCTIONS"
}

################################################
# compile Algo
################################################

# Loop until no more file to import
# 1. generate code from template
# 2. remove duplicated #!/usr/bin/env bash
# 3. inject embeds
# 4. deduce files to import based on [A-Za-z0-9]+::[A-Za-z0-9]+ pattern
#    (skip files already imported and those that do not exist)
# 5. inject import files at the beginning of the file using '# FUNCTIONS'
#    marker
# 6. evaluate again the current compiledFile as a template in the case
#    where injected function are using template function
#    and do again steps 4 and 5
# 7 write compiled file cleaning it a little bit

COMPILED_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_file.XXXXXXX")"
COMPILED_FILE2="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_file2.XXXXXXX")"

# shellcheck disable=SC2034
declare -a filesAlreadyImported=("${INPUT_FILE}")
ROOT_DIR_RELATIVE_TO_BIN_DIR=$'<%% echo "${ROOT_DIR_RELATIVE_TO_BIN_DIR}" %>'
evalTemplate "${INPUT_FILE}" >"${COMPILED_FILE}"

# compute BIN_FILE
if [[ -z "${BIN_FILE}" ]]; then
  BIN_FILE=$(Compiler::getBinFile "${INPUT_FILE}")
  if [[ -z "${BIN_FILE}" ]]; then
    # BIN_FILE directive not provided => skipped
    Log::displaySkipped "File '${INPUT_FILE}' - BIN_FILE directive not provided"
    exit 0
  fi
fi
Log::displayInfo "Compiling ${INPUT_FILE} ..."

# inject embed
injectEmbed "${COMPILED_FILE}"

# now we can evaluate ROOT_DIR_RELATIVE_TO_BIN_DIR as BIN_DIR is known from
# first evalTemplate using BIN_FILE

binDirRelativeToRootDir="$(File::relativeToDir "${_COMPILE_ROOT_DIR}" "$(dirname "${BIN_FILE}")")"
# shellcheck disable=SC1083
ROOT_DIR_RELATIVE_TO_BIN_DIR="\$(cd \"\${BIN_DIR}/${binDirRelativeToRootDir}\" && pwd -P)"

# import the framework functions
injectImportedFunctions "${COMPILED_FILE}" filesAlreadyImported

# evaluate again the current compiledFile as a template in the case
# where injected function are using template function (include files like Env::load
evalTemplate "${COMPILED_FILE}" >"${COMPILED_FILE2}"

# inject again functions in case included file at previous step needs some new functions
# filesAlreadyImported is global variable so we will not reimport already included functions
injectImportedFunctions "${COMPILED_FILE2}" filesAlreadyImported

# remove spaces at the end of the lines
sed -E -i 's/[[:blank:]]+$//' "${COMPILED_FILE2}"

cat -s "${COMPILED_FILE2}" | Filters::directive "${FILTER_DIRECTIVE_REMOVE_HEADERS}" >"${BIN_FILE}"
chmod +x "${BIN_FILE}"

Log::displayStatus "Compiled ${INPUT_FILE} to Binfile ${BIN_FILE}"
exit "${failures}"
