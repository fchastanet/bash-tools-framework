#!/usr/bin/env bash

# generate code from templates <https://github.com/TekWizely/bash-tpl>
#  - auto import function with pattern folder::(._::)_(functionName) =>
#    Folder/functionName.sh
#  - auto import \_.sh before if at least one function imported in the directory
#  - auto import ZZZ.sh after loading functions if at least one function imported in the directory

_COMPILE_BIN_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
_COMPILE_ROOT_DIR="$(cd "${_COMPILE_BIN_DIR}/.." && pwd -P)"
_COMPILE_SRC_DIR="$(cd "${_COMPILE_ROOT_DIR}/src" && pwd -P)"
export FRAMEWORK_DIR="${_COMPILE_ROOT_DIR}"

# shellcheck source=/src/_includes/_header.sh
source "${_COMPILE_SRC_DIR}/_includes/_header.sh"
# shellcheck source=/src/Array/contains.sh
source "${_COMPILE_SRC_DIR}/Array/contains.sh"
# shellcheck source=src/Env/load.sh
source "${_COMPILE_SRC_DIR}/Env/load.sh"
# shellcheck source=src/File/upFind.sh
source "${_COMPILE_SRC_DIR}/File/upFind.sh"
# shellcheck source=src/Log/__all.sh
source "${_COMPILE_SRC_DIR}/Log/__all.sh"
# shellcheck source=/src/Filters/removeDuplicatedShebangs.sh
source "${_COMPILE_SRC_DIR}/Filters/removeDuplicatedShebangs.sh"
# shellcheck source=/src/Filters/catFileCleaned.sh
source "${_COMPILE_SRC_DIR}/Filters/catFileCleaned.sh"
# shellcheck source=/src/Filters/trimEmptyLines.sh
source "${_COMPILE_SRC_DIR}/Filters/trimEmptyLines.sh"
# shellcheck source=/src/Filters/bashFrameworkFunctions.sh
source "${_COMPILE_SRC_DIR}/Filters/bashFrameworkFunctions.sh"

# shellcheck disable=SC2034
((failures = 0)) || true
declare -a srcDirs=()
# shellcheck disable=SC2034
ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
TEMPLATE_DIR="${_COMPILE_SRC_DIR}"

################################################
# Parse options
################################################
# Usage info
showHelp() {
  SCRIPT_NAME=${0##*/}
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} inlines all the functions used in the script given in parameter

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} <fileToCompile> <srcFilePath> <relativePath> <rootDir> [--src-dir|-s <srcDir>] [--template <templateName>]
    --help,-h prints this help and exits

    <fileToCompile> the relative or absolute path to compile into one file

    <srcFilePath> the src file you want to show at the top of generated file to indicate
      from which source file the binary has been generated.
      You can use the variable SRC_FILE_PATH in your template.

    <relativePath> some binary files needs to deduce root path relative to where they
      are installed.
      Eg: this is useful for these binary files to know that to get some configuration files.
      You can use the variable ROOT_DIR_RELATIVE_TO_BIN_DIR in your template.

    <rootDir> useful to include some files during compilation

    --src-dir|-s <srcDir> provide the directory where to find the functions source code.
      By default this project src directory is used.

      You can add as much --src-dir options as needed to define other source dirs.
      The functions will be searched in the order defined (it allows function redefinition)
      Example: --src-dir src --src-dir otherSrc
      Functions::myFunction will be searched in
        - src/Functions/myFunction.sh
        - otherSrc/Functions/myFunction.sh

      ${__HELP_TITLE}Important Note:${__HELP_NORMAL} if you provide a --src-dir and you need also functions
      defined in this project, think about adding a --src-dir for this project too

    --template-dir|-t <templateDir> the template directory to use to override some template includes
      Check environment variables below.

${__HELP_TITLE}Environment variables:${__HELP_NORMAL}
  * REPOSITORY_URL: used in template to indicate from which github repo the file has been generated
  * SRC_ABSOLUTE_PATH: absolute path to the template file being computed
  * ORIGINAL_TEMPLATE_DIR allowing you to include the template relative to the script being interpreted
  * TEMPLATE_DIR the template directory in which you can override the templates defined in ORIGINAL_TEMPLATE_DIR

${__HELP_TITLE}META variables:${__HELP_NORMAL}
It's possible to inject some variables that will be used to interpret the template
Eg: add this line to the beginning of the file without breaking comment section (no newlines between #)
${__HELP_EXAMPLE}
#!/usr/bin/env bash
# META_SCRIPT=MinimumRequirements
The variable SCRIPT can then be used in the template using
SCRIPT="<% \${SCRIPT} %>"
${__HELP_NORMAL}

${__HELP_TITLE}Example:${__HELP_NORMAL}
Let's say you want to generate the binary file bin/buildDoc from the source file src/build/buildDoc.sh
${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh ..${__HELP_NORMAL}

Here you want to generate the binary file bin/buildDoc from the source file src/build/buildDoc.sh
but overriding some or all functions of bash-tools-framework/src
${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh .. -s ./src -s ../bash-tools-framework/src${__HELP_NORMAL}

Here you want to override the default templates too
${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh .. -s ./src -s ../bash-tools-framework/src -t src/templates${__HELP_NORMAL}

$(envsubst <"${_COMPILE_SRC_DIR}/_includes/author.tpl")
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help,src-dir:,template-dir: -o hs:t: -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --src-dir | -s)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      srcDirs+=("$(realpath --physical "$1")")
      ;;
    --template-dir | -t)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      TEMPLATE_DIR="$(realpath --physical "$1")"
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done
# add framework src dir by default
srcDirs+=("${_COMPILE_SRC_DIR}")

if (($# != 4)); then
  Log::fatal "You must provide exactly 4 fixed parameters"
fi

INPUT_FILE="$1"
# the src file you want to show at the top of generated file to indicate
# from which source file the binary has been generated
SRC_FILE_PATH="$2"
# how to join ROOT_DIR from target BIN_FILE directory
ROOT_DIR_RELATIVE_TO_BIN_DIR="$3"
# root dir absolute path
ROOT_DIR="$4"

# try to find .framework-config
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP=^$
NON_FRAMEWORK_FILES_REGEXP=
for srcDir in "${srcDirs[@]}"; do
  configFile="$(File::upFind "${srcDir}" ".framework-config" || true)"
  if [[ -n "${configFile}" ]]; then
    # shellcheck source=/.framework-config
    source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
    Log::displayDebug "Config file ${configFile} is loaded"
  fi
done

################################################
# compile Algo
################################################

# Loop until no more file to import
# 1. generate code from template
# 2. remove duplicated #!/usr/bin/env bash
# 3. deduce files to import based on [A-Za-z0-9]+::[A-Za-z0-9]+ pattern
#    (skip files already imported and those that do not exist)
# 4. inject import files at the beginning of the file
# TODO I could get rid of bash-tpl by providing special function IMPORT::dir::file
#    this function should be replaced inline

COMPILED_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_file.XXXXXXX")"
COMPILED_FILE2="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_fil2e.XXXXXXX")"

# shellcheck disable=SC2317
dynamicTemplateDir() {
  local file="$1"
  if [[ ! -f "${file}" ]]; then
    if [[ -f "${TEMPLATE_DIR}/${file}" ]]; then
      echo "${TEMPLATE_DIR}/${file}"
      return 0
    elif [[ -f "${ORIGINAL_TEMPLATE_DIR}/${file}" ]]; then
      echo "${ORIGINAL_TEMPLATE_DIR}/${file}"
      return 0
    fi
  fi
  echo "${file}"
}
export -f dynamicTemplateDir

evalTemplate() {
  local FILE="$1"
  local metaExports
  # https://regex101.com/r/7zDYFK/1
  metaExports="$(
    sed -E -n '/^#/!q;p' "${FILE}" |
      grep -E '# META_.*=' |
      sed -E 's/^#[ \t]+META_([^=]+)=[ \t]*([^\n\r]*)/\1="\2"\nexport \1\n/g' |
      tr '\n' ' ' ||
      :
  )"
  if [[ "${DEBUG:-0}" = "1" ]]; then
    (echo >&2 -e "${__DEBUG_COLOR}\tevalTemplate source <(
      ${metaExports}
      SRC_FILE_PATH='${SRC_FILE_PATH}'
      REPOSITORY_URL='${REPOSITORY_URL}'
      ORIGINAL_TEMPLATE_DIR='${_COMPILE_SRC_DIR}'
      TEMPLATE_DIR='${TEMPLATE_DIR}'
      ROOT_DIR='${ROOT_DIR}'
      ROOT_DIR_RELATIVE_TO_BIN_DIR='${ROOT_DIR_RELATIVE_TO_BIN_DIR}'
      FRAMEWORK_ROOT_DIR='${_COMPILE_ROOT_DIR}'
      SRC_ABSOLUTE_PATH='${SRC_ABSOLUTE_PATH}'
      ${_COMPILE_ROOT_DIR}/bin/bash-tpl '${FILE}'
      ) > binFile${__RESET_COLOR}")
  fi
  SRC_ABSOLUTE_PATH="$(realpath "${SRC_FILE_PATH}")"
  (# shellcheck disable=SC2034
    cd "${TEMPLATE_DIR}"
    eval "${metaExports}"
    ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
    FRAMEWORK_ROOT_DIR="${_COMPILE_ROOT_DIR}"
    export TEMPLATE_DIR
    export SRC_FILE_PATH
    export REPOSITORY_URL
    export ORIGINAL_TEMPLATE_DIR
    export TEMPLATE_DIR
    export ROOT_DIR
    export ROOT_DIR_RELATIVE_TO_BIN_DIR
    export FRAMEWORK_ROOT_DIR
    export SRC_ABSOLUTE_PATH
    # shellcheck source=/dev/null
    source <("${_COMPILE_ROOT_DIR}/bin/bash-tpl" "${FILE}")
  ) | Filters::removeDuplicatedShebangs
}

evalTemplate "${INPUT_FILE}" >"${COMPILED_FILE}"

injectImportedFunctions() {
  local file="$1"
  local -n filesImported=$2

  local functionsNeedToBeImported
  local -a functionsToImport
  local iteration zzzFile fileToImport underscoreFile
  local importedFunctionsTempFile
  importedFunctionsTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_functions.XXXXXXX")"

  local importedZZZTempFile
  importedZZZTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_zzz_files.XXXXXXX")"

  ((functionsNeedToBeImported = 1))
  ((iteration = 1))
  while ((functionsNeedToBeImported >= 1)); do
    if [[ "${DEBUG:-0}" = "1" ]]; then
      (echo >&2 -e "${__DEBUG_COLOR}\tIteration #${iteration}${__RESET_COLOR}")
    fi
    echo >"${importedFunctionsTempFile}"
    echo >"${importedZZZTempFile}"

    readarray -t functionsToImport < <(
      Filters::bashFrameworkFunctions "${file}" |
        awk '{$1=$1};1' |
        sort |
        uniq
    )
    ((functionsNeedToBeImported = 0)) || true
    for functionToImport in "${functionsToImport[@]}"; do
      if echo "${functionToImport}" | grep -q -E "${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP}"; then
        (echo >&2 -e "${__DEBUG_COLOR}\tFunction ${functionToImport} ignored, because of rule defined in ${configFile}${__RESET_COLOR}")
        continue
      fi

      local fileNameToImport
      fileNameToImport="$(echo "${functionToImport}" | sed -E 's#::#/#g').sh"
      # search through srcDirs the file to import
      for srcDir in "${srcDirs[@]}"; do
        fileToImport="${srcDir}/${fileNameToImport}"
        if [[ -f "${fileToImport}" ]]; then
          # we found it
          break
        fi
      done

      if ! Array::contains "${fileToImport}" "${filesImported[@]}"; then
        if [[ -f "${fileToImport}" ]]; then
          # check if we need to import _.sh
          underscoreFile="$(dirname "${fileToImport}")/_.sh"
          if ! Array::contains "${underscoreFile}" "${filesImported[@]}" &&
            [[ -f "${underscoreFile}" ]]; then
            if [[ "${DEBUG:-0}" = "1" ]]; then
              (echo >&2 -e "${__DEBUG_COLOR}\tImporting ${underscoreFile} ...${__RESET_COLOR}")
            fi
            Filters::catFileCleaned "${underscoreFile}" >>"${importedFunctionsTempFile}"
            filesImported+=("${underscoreFile}")
          fi
          # check if we need to import ZZZ.sh
          zzzFile="$(dirname "${fileToImport}")/ZZZ.sh"
          if ! Array::contains "${zzzFile}" "${filesImported[@]}" &&
            [[ -f "${zzzFile}" ]]; then
            if [[ "${DEBUG:-0}" = "1" ]]; then
              (echo >&2 -e "${__DEBUG_COLOR}\tImporting ${zzzFile} ...${__RESET_COLOR}")
            fi
            Filters::catFileCleaned "${zzzFile}" >>"${importedZZZTempFile}"
            filesImported+=("${zzzFile}")
          fi

          if [[ "${DEBUG:-0}" = "1" ]]; then
            (echo >&2 -e "\t${__DEBUG_COLOR}Importing ${fileToImport} ...${__RESET_COLOR}")
          fi
          Filters::catFileCleaned "${fileToImport}" >>"${importedFunctionsTempFile}"
        else
          (echo >&2 -e "${__ERROR_COLOR}\tFile ${fileToImport} does not exist${__RESET_COLOR}")
          ((failures++)) || true
        fi
        filesImported+=("${fileToImport}")
        ((functionsNeedToBeImported = 1)) # as we added some files, we need to do another pass
      fi
    done

    # insert functions before # FUNCTIONS
    sed -E -i "/# FUNCTIONS/ e cat ${importedFunctionsTempFile}\n" "${file}"

    # insert zzz files after # FUNCTIONS
    sed -E -i "/# FUNCTIONS/ r ${importedZZZTempFile}" "${file}"

    ((iteration++))
  done
}

# shellcheck disable=SC2034
declare -a FILES_IMPORTED=("${INPUT_FILE}")

injectImportedFunctions "${COMPILED_FILE}" FILES_IMPORTED

# evaluate again the current compiledFile as a template in the case
# where injected function are using template function (include files like Env::load
if [[ "${DEBUG:-0}" = "1" ]]; then
  (echo >&2 -e "${__DEBUG_COLOR}\tevalTemplate2${__RESET_COLOR}")
fi
evalTemplate "${COMPILED_FILE}" >"${COMPILED_FILE2}"

# inject again functions in case included file at previous step needs some new functions
# FILES_IMPORTED is global variable so we will not reimport already included functions
if [[ "${DEBUG:-0}" = "1" ]]; then
  (echo >&2 -e "${__DEBUG_COLOR}\tinjectImportedFunctions2${__RESET_COLOR}")
fi
injectImportedFunctions "${COMPILED_FILE2}" FILES_IMPORTED

# remove spaces at the end of the lines
sed -E -i 's/[[:blank:]]+$//' "${COMPILED_FILE2}"

cat -s "${COMPILED_FILE2}"

exit "${failures}"
