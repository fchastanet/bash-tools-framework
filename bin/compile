#!/usr/bin/env bash

# generate code from templates <https://github.com/TekWizely/bash-tpl>
#  - auto import function with pattern folder::(._::)_(functionName) =>
#    Folder/functionName.sh
#  - auto import \_.sh before if at least one function imported in the directory
#  - auto import ZZZ.sh after loading functions if at least one function imported in the directory

_COMPILE_BIN_DIR="$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)"
_COMPILE_ROOT_DIR="$(cd "${_COMPILE_BIN_DIR}/.." && pwd -P)"
_COMPILE_SRC_DIR="$(cd "${_COMPILE_ROOT_DIR}/src" && pwd -P)"
export FRAMEWORK_DIR="${_COMPILE_ROOT_DIR}"

# shellcheck source=/src/_includes/_header.sh
source "${_COMPILE_SRC_DIR}/_includes/_header.sh"
# shellcheck source=/src/Array/contains.sh
source "${_COMPILE_SRC_DIR}/Array/contains.sh"
# shellcheck source=/src/Assert/validPath.sh
source "${_COMPILE_SRC_DIR}/Assert/validPath.sh"
# shellcheck source=/src/File/upFind.sh
source "${_COMPILE_SRC_DIR}/File/upFind.sh"
# shellcheck source=/src/Conf/loadNearestFile.sh
source "${_COMPILE_SRC_DIR}/Conf/loadNearestFile.sh"
# shellcheck source=/src/Framework/loadConfig.sh
source "${_COMPILE_SRC_DIR}/Framework/loadConfig.sh"
# shellcheck source=src/Env/load.sh
source "${_COMPILE_SRC_DIR}/Env/load.sh"
# shellcheck source=src/File/upFind.sh
source "${_COMPILE_SRC_DIR}/File/upFind.sh"
# shellcheck source=src/File/relativeToDir.sh
source "${_COMPILE_SRC_DIR}/File/relativeToDir.sh"
# shellcheck source=src/Log/__all.sh
source "${_COMPILE_SRC_DIR}/Log/__all.sh"
# shellcheck source=/src/Filters/removeDuplicatedShebangs.sh
source "${_COMPILE_SRC_DIR}/Filters/removeDuplicatedShebangs.sh"
# shellcheck source=/src/Filters/catFileCleaned.sh
source "${_COMPILE_SRC_DIR}/Filters/catFileCleaned.sh"
# shellcheck source=/src/Filters/trimEmptyLines.sh
source "${_COMPILE_SRC_DIR}/Filters/trimEmptyLines.sh"
# shellcheck source=/src/Filters/bashFrameworkFunctions.sh
source "${_COMPILE_SRC_DIR}/Filters/bashFrameworkFunctions.sh"
# shellcheck source=/src/Filters/bashCommentLines.sh
source "${_COMPILE_SRC_DIR}/Filters/bashCommentLines.sh"
# shellcheck source=/src/Filters/metadata.sh
source "${_COMPILE_SRC_DIR}/Filters/metadata.sh"
# shellcheck source=/src/Filters/metadataValue.sh
source "${_COMPILE_SRC_DIR}/Filters/metadataValue.sh"
# shellcheck source=/src/Compiler/extractMetaForExport.sh
source "${_COMPILE_SRC_DIR}/Compiler/extractMetaForExport.sh"
# shellcheck source=/src/Compiler/extractUniqueFrameworkFunctions.sh
source "${_COMPILE_SRC_DIR}/Compiler/extractUniqueFrameworkFunctions.sh"
# shellcheck source=/src/Compiler/findFunctionInSrcDirs.sh
source "${_COMPILE_SRC_DIR}/Compiler/findFunctionInSrcDirs.sh"
# shellcheck source=/src/Compiler/getBinFile.sh
source "${_COMPILE_SRC_DIR}/Compiler/getBinFile.sh"
# shellcheck source=/src/Compiler/injectFileOnce.sh
source "${_COMPILE_SRC_DIR}/Compiler/injectFileOnce.sh"
# shellcheck source=/src/File/insertFileBeforeToken.sh
source "${_COMPILE_SRC_DIR}/File/insertFileBeforeToken.sh"
# shellcheck source=/src/File/insertFileAfterToken.sh
source "${_COMPILE_SRC_DIR}/File/insertFileAfterToken.sh"

# shellcheck disable=SC2034
((failures = 0)) || true
declare -a srcDirs=()
# shellcheck disable=SC2034
ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
# root dir absolute path
ROOT_DIR="${_COMPILE_ROOT_DIR}"
KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

################################################
# Parse options
################################################
# Usage info
showHelp() {
  SCRIPT_NAME=${0##*/}
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} inlines all the functions used in the
script given in parameter

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} <fileToCompile>
    [--src-dir|-s <srcDir>] [--bin-dir|-b <binDir>] [--template <templateName>]
    [--root-dir|-r <rootDir>] [--src-path <srcPath>] [--keep-temp-files|-k]

${__HELP_TITLE}Mandatory Arguments:${__HELP_NORMAL}

    <fileToCompile> the relative or absolute path to compile into
      one file

    <srcFilePath> the src file you want to show at the top of
      generated file to indicate from which source file the binary
      has been generated.
      You can use the variable SRC_FILE_PATH in your template.

${__HELP_TITLE}Options:${__HELP_NORMAL}
    --help,-h prints this help and exits

    --src-dir|-s <srcDir> provide the directory where to find the
      functions source code.
      By default this project src directory is used.

      You can add as much --src-dir options as needed to define
      other source dirs.
      The functions will be searched in the order defined (it
      allows function redefinition)
      Example: --src-dir src --src-dir otherSrc
      Functions::myFunction will be searched in
        - src/Functions/myFunction.sh
        - otherSrc/Functions/myFunction.sh

      ${__HELP_TITLE}Important Note:${__HELP_NORMAL} if you provide
      a --src-dir and you need also functions defined in this
      project, think about adding a --src-dir for this project too

    --bin-dir|-b <binDir> allows to override the value of BIN_DIR
      by default BIN_DIR is set to '${ROOT_DIR}/bin'

    --template-dir|-t <templateDir> the template directory to use
      to override some template includes.
      Check environment variables below.

    --root-dir|-r <rootDir> if you whish to override ROOT_DIR
      variable (default value is '${ROOT_DIR}'

    --src-path <path> if you wish to override the filepath that will
      be displayed in the header to indicate the src filepath that
      has been compiled (SRC_FILE_PATH).
      By default, it is initialized with path relative to ROOT_DIR

    --keep-temp-files|-k keep temporary files for debug purpose

${__HELP_TITLE}.framework-config environment variables:${__HELP_NORMAL}
  You can define global environement variables inside
  .framework-config file that could be used in your templates:
  Eg:
    * REPOSITORY_URL: used in template to indicate from which github
      repo the file has been generated

${__HELP_TITLE}Template variables:${__HELP_NORMAL}
  Other variables are automatically generated to be used in your
  templates:
    * ORIGINAL_TEMPLATE_DIR allowing you to include the template
      relative to the script being interpreted
    * TEMPLATE_DIR the template directory in which you can override
      the templates defined in ORIGINAL_TEMPLATE_DIR
    * ROOT_DIR_RELATIVE_TO_BIN_DIR is automatically computed from
      BIN_FILE metadata. It allows to generate the framework root dir
      during runtime.
      Kept for compatibility reason but prefer to use Embed feature
      instead.

  The following variables depends upon parameters passed to this
  script:
    * SRC_FILE_PATH the src file you want to show at the top of
      generated file to indicate from which source file the binary
      has been generated.
    * SRC_ABSOLUTE_PATH is the path of the file being compiled, it
      can be useful if you need to access a path relative to this
      file during compilation.

${__HELP_TITLE}Bash-tpl Templating:${__HELP_NORMAL}
  your compiled source file will be interpreted using bash-tpl
  https://github.com/TekWizely/bash-tpl
  You can use this feature to inline external file, interpreting
  environment variable during compilation, ...
  ${__HELP_EXAMPLE}
  Eg: inline a awk script inside the resulting
  binary
  awkScript="\$(
    cat <<'AWK_EOF'
  .INCLUDE "\$(cd "\$(dirname \${SRC_ABSOLUTE_PATH})" && pwd -P)/mysql2puml.awk"
  AWK_EOF
  )"${__HELP_NORMAL}

${__HELP_TITLE}META variables:${__HELP_NORMAL}
  It's also possible to inject some variables speficic to the binary
  file you are generating and that will be used to interpret your
  templates.
${__HELP_EXAMPLE}
  Eg: add this line to the beginning of the source file without
  breaking comment section (no newlines between #)

  #!/usr/bin/env bash
  # META_SCRIPT=MinimumRequirements${__HELP_NORMAL}

  The variable SCRIPT can then be used in the template using
  ${__HELP_EXAMPLE}SCRIPT="<% \${SCRIPT} %>"${__HELP_NORMAL}

${__HELP_TITLE}Examples:${__HELP_NORMAL}
  Let's say you want to generate the binary file \`bin/buildDoc\`
  from the source file \`src/build/buildDoc.sh\`
  ${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh ..${__HELP_NORMAL}

  Here you want to generate the binary but overriding some or
  all functions of bash-tools-framework/src
  ${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh ..\\
  -s ./src -s ../bash-tools-framework/src${__HELP_NORMAL}

  Here you want to override the default templates too
  ${__HELP_EXAMPLE}${SCRIPT_NAME} src/build/buildDoc.sh src/build/buildDoc.sh .. \\
  -s ./src -s ../bash-tools-framework/src -t src/templates${__HELP_NORMAL}

${__HELP_TITLE}Src file annotation:${__HELP_NORMAL}
  You can use special annotations in src file

  ${__HELP_TITLE}BIN_FILE annotation (optional):${__HELP_NORMAL}
  allows to indicate where the resulting bin file will be generated
  if not provided, the binary file will be copied to {binDir} without sh extension

  ${__HELP_TITLE}INCLUDE annotation (optional):${__HELP_NORMAL}
    ${__HELP_EXAMPLE}Syntax: # INCLUDE "srcFile" AS "targetFile"${__HELP_NORMAL}
    ${__HELP_EXAMPLE}Syntax: # INCLUDE "srcDir" AS "targetDir"${__HELP_NORMAL}
    ${__HELP_EXAMPLE}Syntax: # INCLUDE namespace::functions AS "myFunction"${__HELP_NORMAL}
    if INCLUDE annotation is provided, the file/dir provided will be added inside the resulting
    bin file as a tar gz file(base64 encoded) and automatically extracted when executed.

${__HELP_TITLE}File header example:${__HELP_NORMAL}
${__HELP_EXAMPLE}
#!/usr/bin/env bash
# BIN_FILE=\${ROOT_DIR}/bin/myBinary
# META_SCRIPT=MinimumRequirements
# INCLUDE "\${ROOT_DIR}/bin/otherNeededBinary" AS "otherNeededBinary"
# INCLUDE Backup::file AS "backupFile"
sudo "\${embed_file_backupFile}" ...
"\${embed_file_otherNeededBinary}"${__HELP_NORMAL}

$(SRC_FILE_PATH=bin/compile envsubst <"${_COMPILE_SRC_DIR}/_includes/authorHardCoded.tpl")
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
longOpts="help,src-dir:,template-dir:,bin-dir:,root-dir:,src-path,keep-temp-files"
shortOpts="hks:t:b:r:"
options=$(getopt -l "${longOpts}" -o "${shortOpts}" -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --src-dir | -s)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      srcDirs+=("$(realpath --physical "$1")")
      ;;
    --template-dir | -t)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      TEMPLATE_DIR="$(realpath --physical "$1")"
      ;;
    --bin-dir | -b)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      BIN_DIR="$(realpath --physical "$1")"
      ;;
    --root-dir | -r)
      shift || true
      if [[ ! -d "$1" ]]; then
        Log::fatal "Directory '$1' does not exists"
      fi
      ROOT_DIR="$(realpath --physical "$1")"
      ;;
    --src-path)
      shift || true
      if ! Assert::validPath "$1"; then
        Log::fatal "Src path '$1' is not a valid path"
      fi
      SRC_FILE_PATH="$1"
      ;;
    --keep-temp-files | -k)
      KEEP_TEMP_FILES=1
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done
# add framework src dir by default
srcDirs+=("${_COMPILE_SRC_DIR}")

if (($# != 1)); then
  Log::fatal "You must provide exactly 1 fixed parameter"
fi

# The file to compile
INPUT_FILE="$1"
# the src file you want to show at the top of generated file to indicate
# from which source file the binary has been generated
if [[ -z "${SRC_FILE_PATH+xxx}" ]]; then
  SRC_FILE_PATH="$(File::relativeToDir "${INPUT_FILE}" "${ROOT_DIR}")"
fi

# if bin dir has not been set, set a default value
if [[ -z "${BIN_DIR+xxx}" ]]; then
  BIN_DIR="${ROOT_DIR}/bin"
fi
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP=^$

# load .framework-config
configFile=""
# shellcheck source=/.framework-config
Framework::loadConfig configFile "${srcDirs[@]}" || Log::fatal "error while loading .framework-config file"

# shellcheck disable=SC2317
dynamicTemplateDir() {
  local file="$1"
  if [[ ! -f "${file}" ]]; then
    if [[ -f "${TEMPLATE_DIR}/${file}" ]]; then
      echo "${TEMPLATE_DIR}/${file}"
      return 0
    elif [[ -f "${ORIGINAL_TEMPLATE_DIR}/${file}" ]]; then
      echo "${ORIGINAL_TEMPLATE_DIR}/${file}"
      return 0
    fi
  fi
  echo "${file}"
}
export -f dynamicTemplateDir

evalTemplate() {
  local FILE="$1"
  local metaExports
  metaExports="$(Compiler::extractMetaForExport "${FILE}")"
  SRC_ABSOLUTE_PATH="$(realpath "${SRC_FILE_PATH}")"
  (
    cd "${TEMPLATE_DIR}"
    eval "${metaExports}"
    ORIGINAL_TEMPLATE_DIR="${_COMPILE_SRC_DIR}"
    export BIN_DIR
    export ROOT_DIR
    export ORIGINAL_TEMPLATE_DIR
    export TEMPLATE_DIR
    export SRC_ABSOLUTE_PATH
    export SRC_FILE_PATH
    export ROOT_DIR_RELATIVE_TO_BIN_DIR
    # shellcheck source=/dev/null
    source <("${_COMPILE_ROOT_DIR}/bin/bash-tpl" "${FILE}")
  ) | Filters::removeDuplicatedShebangs
}

importFunctions() {
  local file="$1"
  local importedFunctionsTempFile="$2"
  local importedZZZTempFile="$3"
  local -n filesImportedWithFunctions=$4
  local -n newFilesAdded=$5
  local -n importFailures=$6
  local -a functionsToImport
  local functionToImport

  readarray -t functionsToImport < <(Compiler::extractUniqueFrameworkFunctions "${file}")

  ((newFilesAdded = 0)) || true
  if [[ "${DEBUG:-0}" = "1" ]]; then
    echo >&2 "importing ${file} with ${#functionsToImport[@]} functions to import"
  fi
  for functionToImport in "${functionsToImport[@]}"; do
    if echo "${functionToImport}" | grep -q -E "${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP}"; then
      (echo >&2 -e "${__DEBUG_COLOR}\tFunction ${functionToImport} ignored, because of rule defined in ${configFile}${__RESET_COLOR}")
      continue
    fi

    local fileToImport
    fileToImport="$(Compiler::findFunctionInSrcDirs "${functionToImport}" "${srcDirs[@]}")" || {
      (echo >&2 -e "${__ERROR_COLOR}\tFunction ${functionToImport} not found in any src directories${__RESET_COLOR}")
      ((importFailures++)) || true
      continue
    }

    if Array::contains "${fileToImport}" "${filesImportedWithFunctions[@]}"; then
      continue
    fi

    if [[ -f "${fileToImport}" ]]; then
      local fileToImportDir
      fileToImportDir="$(dirname "${fileToImport}")"
      # check if we need to import _.sh
      if [[ -f "${fileToImportDir}/_.sh" ]]; then
        Compiler::injectFileOnce "${fileToImportDir}/_.sh" \
          filesImportedWithFunctions >>"${importedFunctionsTempFile}"
      fi
      # check if we need to import ZZZ.sh
      if [[ -f "${fileToImportDir}/ZZZ.sh" ]]; then
        Compiler::injectFileOnce "${fileToImportDir}/ZZZ.sh" \
          filesImportedWithFunctions >>"${importedZZZTempFile}"
      fi
      Compiler::injectFileOnce "${fileToImport}" \
        filesImportedWithFunctions >>"${importedFunctionsTempFile}"

      # shellcheck disable=SC2034
      ((newFilesAdded = 1)) # as we added some files, we need to do another pass
    else
      (echo >&2 -e "${__ERROR_COLOR}\tFile ${fileToImport} does not exist${__RESET_COLOR}")
      # even if not existing, consider the file as imported to avoid other same errors
      filesImportedWithFunctions+=("${fileToImport}")
      ((importFailures++)) || true
    fi
  done
}

injectImportedFunctions() {
  local file="$1"
  # shellcheck disable=SC2034
  local -n filesImported=$2

  local needAnotherPass
  local -a functionsToImport
  local iteration
  local fileToImport

  local importedFunctionsTempFile
  importedFunctionsTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_functions.XXXXXXX")"
  local importedZZZTempFile
  importedZZZTempFile="$(mktemp -p "${TMPDIR:-/tmp}" -t "imported_zzz_files.XXXXXXX")"

  ((needAnotherPass = 1))
  ((iteration = 1))
  while ((needAnotherPass >= 1)); do
    if [[ "${DEBUG:-0}" = "1" ]]; then
      (echo >&2 -e "${__DEBUG_COLOR}\tIteration #${iteration}${__RESET_COLOR}")
    fi
    echo >"${importedFunctionsTempFile}"
    echo >"${importedZZZTempFile}"

    importFunctions "${file}" "${importedFunctionsTempFile}" "${importedZZZTempFile}" \
      filesImported needAnotherPass failures

    # insert functions before # FUNCTIONS
    File::insertFileBeforeToken "${file}" "${importedFunctionsTempFile}" "# FUNCTIONS"

    # insert zzz files after # FUNCTIONS
    File::insertFileAfterToken "${file}" "${importedZZZTempFile}" "# FUNCTIONS"

    ((iteration++))
  done
}

################################################
# compile Algo
################################################

# Loop until no more file to import
# 1. generate code from template
# 2. remove duplicated #!/usr/bin/env bash
# 3. deduce files to import based on [A-Za-z0-9]+::[A-Za-z0-9]+ pattern
#    (skip files already imported and those that do not exist)
# 4. inject import files at the beginning of the file

COMPILED_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_file.XXXXXXX")"
COMPILED_FILE2="$(mktemp -p "${TMPDIR:-/tmp}" -t "compiled_fil2e.XXXXXXX")"

# share this command arguments to allow Embed to compile files using same
# parameters
declare -agx _COMPILE_FILE_ARGUMENTS=("$@")

# shellcheck disable=SC2034
declare -a filesAlreadyImported=("${INPUT_FILE}")
ROOT_DIR_RELATIVE_TO_BIN_DIR=$'<%% echo "${ROOT_DIR_RELATIVE_TO_BIN_DIR}" %>'
evalTemplate "${INPUT_FILE}" >"${COMPILED_FILE}"

# compute BIN_FILE
BIN_FILE=$(Compiler::getBinFile "${INPUT_FILE}")
export BIN_FILE
if [[ -z "${BIN_FILE}" ]]; then
  # BIN_FILE metadata not provided => skipped
  Log::displaySkipped "File '${INPUT_FILE}' - BIN_FILE metadata not provided"
  return 0
fi
Log::displayInfo "Binfile ${BIN_FILE} from ${INPUT_FILE}"

# now we can evaluate ROOT_DIR_RELATIVE_TO_BIN_DIR as BIN_DIR is known from
# first evalTemplate using BIN_FILE
binDirRelativeToRootDir="$(File::relativeToDir "${_COMPILE_ROOT_DIR}" "$(dirname "${BIN_FILE}")")"
# shellcheck disable=SC1083
ROOT_DIR_RELATIVE_TO_BIN_DIR="\$(cd \"\${BIN_DIR}/${binDirRelativeToRootDir}\" && pwd -P)"

# import the framework functions
injectImportedFunctions "${COMPILED_FILE}" filesAlreadyImported

# evaluate again the current compiledFile as a template in the case
# where injected function are using template function (include files like Env::load
evalTemplate "${COMPILED_FILE}" >"${COMPILED_FILE2}"

# inject again functions in case included file at previous step needs some new functions
# filesAlreadyImported is global variable so we will not reimport already included functions
injectImportedFunctions "${COMPILED_FILE2}" filesAlreadyImported

# remove spaces at the end of the lines
sed -E -i 's/[[:blank:]]+$//' "${COMPILED_FILE2}"

cat -s "${COMPILED_FILE2}" | Filters::metadata "${FILTER_META_DATA_REMOVE_HEADERS}" >"${BIN_FILE}"
chmod +x "${BIN_FILE}"

exit "${failures}"
